<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ethereum钱包功能开发之环境搭建</title>
      <link href="/archives/426a759f.html"/>
      <url>/archives/426a759f.html</url>
      
        <content type="html"><![CDATA[<p>　　最近在进行ethereum钱包功能的开发，在这里将实现钱包功能过程中遇到的问题进行记录。<a id="more"></a>从当前的进度来看，打算分为几篇文章来记录开发过程中的经历，算是对自己工作过程中进行一个记录与总结。</p><h2 id="常见工具介绍"><a href="#常见工具介绍" class="headerlink" title="常见工具介绍"></a>常见工具介绍</h2><p>　　在进行Ethereum平台相关内容开发时可能会看到<code>Geth</code>，<code>Mist</code>,<code>Truffle</code>,<code>Ganache</code>等，这里对他们的区别做一个简单区分：</p><ul><li>Geth:是Ethereum的一个客户端实现，用于节点搭建等，是使用golang来实现的；</li><li>Parity Ethereum,号称最快、最安全、最稳定的一个Ethereum客户端实现，是使用Rust来开发的；</li><li>Mist:是etherum官方出的一个区块链浏览器，能够让用于进行交易，合约调用等；</li><li>Truffle：简单的理解它是一个<strong>以太坊合约开发工具</strong>，它可以在智能合约开发、测试、发布等过程更方便，关于Truffle更多详细资料，<a href="">查看这里</a></li><li>Ganache：是一个为开发者提供的<strong>私有Ethereum 区块链客户端</strong>, 可以用于本地部署, 开发, 测试应用程序, 测试代码,<a href="https://truffleframework.org/docs/getting_started/client" target="_blank" rel="noopener">更多介绍查看这里</a><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2>　　为便于提供不同平台的支持，我们使用Rust来实现钱包底层的功能，借助Rust交叉编译的便捷性，能够很方便的编译出目标平台所需要的动态库。借助Flutter在界面上实现的跨平台技术，能够解决Andorid,IOS等平台的一致性问题。关于<a href="https://www.rust-lang.org/zh-CN/" target="_blank" rel="noopener">Rust</a>、<a href="https://flutter.dev/" target="_blank" rel="noopener">Flutter</a>的介绍可以点击链接进行了解，关于搭建Rust、Flutter交叉编译环境过程,可以<a href="https://dev.to/robertohuertasm/rust-once-and-share-it-with-android-ios-and-flutter-286o" target="_blank" rel="noopener">参考这篇文章</a>。本文重点对支持ethereum开发所需的环境搭建进行叙述。<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2>　　由于前期有开发<a href="https://substrate.dev/" target="_blank" rel="noopener">Substrate</a>的经验，知道ethereum与substrate来源的关系，开发过程中需要搭建一个节点来接收JsonRpc的请求。所以在ethereum钱包开发中也需要节点来参与调试。按照这种思路，我首先想到的是在本地直接运行一个ethereum节点，接入测试链或者搭建一个私链。由于使用Rust的原因，节点的选择上就自然的想到了Parity Ethereum（由于某些原因现在已经转移到<a href="https://discordapp.com/invite/JCuNu3m" target="_blank" rel="noopener">OpenEthereum DAO</a>）。<h2 id="节点程序编译"><a href="#节点程序编译" class="headerlink" title="节点程序编译"></a>节点程序编译</h2>　　从github上取回<a href="https://github.com/OpenEthereum/open-ethereum" target="_blank" rel="noopener">最新的代码</a>，进入项目的根目录，直接使用rust的编译命令<code>Cargo build --release</code>进行编译，等待几分钟之后就可以编译完成，编译生成的可执行程序在<code>./target/release/</code>目录下。直接运行<code>./parity</code>默认会启动一个全节点，会进行区块数据同步等操作，针对我们仅仅是想测试来说，不需要接入主网参与数据同步。<h3 id="可执行程序介绍"><a href="#可执行程序介绍" class="headerlink" title="可执行程序介绍"></a>可执行程序介绍</h3>在运行<code>./parity --help</code>后，可以看到程序支持的一些可选参数：</li><li>–jsonrpc-apis，可选的值有：all, safe, debug, web3, net, eth, pubsub, personal, signer, parity, parity_pubsub,parity_accounts, parity_set, traces, rpc, secretstore, shh, shh_pubsub.这些rpc接口不是在每个节点都对外开放的，节点的类型也很多，所以在开发的时候确保所选的节点有开放你所需要的rpc接口这点很重要，涉及到技术方案的选择以及实现难度、工作量等问题。</li><li>–chain=[CHAIN]，可选的值有poacore, tobalaba, expanse,musicoin, ellaism, mix, callisto, morden, ropsten, kovan, rinkeby,goerli, kotti, poasokol, testnet, or dev，根据需要启动的节点类型，指定对应的chain。</li><li>–bootnodes,这个值是需要接入的节点地址，每个节点启动的时候都会输出当前自身节点的地址，用于其他节点的直接连接，地址格式如下：<code>enode://xxxx@ip:port</code><br>　　除了跟启动参数外，<code>./parity</code>还提供很多工具命令，比如节点自身也具有钱包管理的功能，能够生成账户地址:运行<code>parity account new</code>，输入密码之后就会生成一个账户地址，同时该账户的私钥信息保存在<code>~/.local/share/io.parity.ethereum/keys/ethereum/</code>路径下。若是在启动节点的时候需要启用挖矿功能，则直接添加 <code>--author [地址]</code>，比如：<code>./parity --author 0037a6b811ffeb6e072da21179d11b1406371c63</code>,地址是去掉<code>0x</code>前缀的<h2 id="节点启动"><a href="#节点启动" class="headerlink" title="节点启动"></a>节点启动</h2>　　由于我仅仅是想测试依赖节点的Rpc服务来验证钱包拼接的数据结构是否满足接口要求，所以我使用的启动方式是使用<code>parity --config dev</code>启动ETH开发节点，同时该节点默认存在一个地址<code>0x00a329c0648769a73afac7f9381e08fb43dbea72</code>，对应的私钥为：<code>0x4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7</code>（这个私钥仅用于开发测试，正式使用时请保存好自己的私钥），该账户中存在一定数目的测试ETH　token，可以用于后续的开发测试。<h2 id="常用Rpc"><a href="#常用Rpc" class="headerlink" title="常用Rpc"></a>常用Rpc</h2>　　虽然有不同的类型的节点，但是他们都有eth开头的最基础Rpc接口，我们可以借助这些接口实现我们的交易数据提交等功能，以下列举出的常用接口使用方式：</li><li><code>eth_getTransactionCount</code>，熟悉区块链开发的都清楚每笔交易都需要一个nonce,用于避免交易的重放攻击，确保交易的执行顺序，在拼接交易之前需要获取交易发起方当前总共发起的交易数，比如<code>curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionCount&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39;  -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code></li><li><code>eth_sendRawTransaction</code>，用于构造离线交易签名，这种方式在钱包开发里面使用的场景比较多，需要依赖特定的节点就可以将交易提交到链上进行验证，这里稍微麻烦的是Rpc请求参数的构造，这在后面的文章做详细的介绍。该API请求数据格式:<code>curl --data &#39;{&quot;method&quot;:&quot;eth_sendRawTransaction&quot;,&quot;params&quot;:[&quot;0xf86d808253e8837a1200941c9baedc94600b2d1c8a6d2bad1744e6182f300e8609184e72a0008568656c6c6f29a0a65b500258e5cf458db262758786e5c327285c924df687b8e9ce28e2fccb9451a07359f8dba84300d950bb534ac71a8d0eccb2a7e01a8cb70041c886588424be1c&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code>。 </li><li><code>eth_getTransactionByHash</code>，在<code>eth_sendRawTransaction</code>的Rpc请求中会返回当前交易的结果。假如交易参数验证通过，会返回当前交易的hash，通过该Rpc可以查看该交易的具体详情，该API数据请求格式如下：<code>curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x1486d4ff14e7fc6f991c17633e2b7a65ae52fc7a1be33845773a561a6955929e&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code></li><li><code>eth_getBalance</code>，针对交易来说，比较重要的一个功能是查询指定地址上的ETH token数量,该API数据请求格式如下:<code>curl --data &#39;{&quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code><br>　　以上是在钱包开发中使用频率较高的一些RPC接口，关于parity Ethereum的介绍以及使用文档，可以查看<a href="https://wiki.parity.io/Parity-Ethereum" target="_blank" rel="noopener">这里</a>了解更多。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>　　以上就是使用Ethereum来实现钱包功能所需要了解的一些内容，关于用户账户、交易构成、合约调用等内容后续慢慢的更新。虽然前期有substrate开发的经验，但是在实现的过程中也遇到了一些问题，我想把遇到的问题记录下来，再把解决问题过程中查阅的内容消化后记录下来，算是自己的学习笔记，可以用于自己以后复习。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Ethereum </tag>
            
            <tag> JsonRpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译出现clear_on_drop错误的解决过程</title>
      <link href="/archives/1c5692ea.html"/>
      <url>/archives/1c5692ea.html</url>
      
        <content type="html"><![CDATA[<p>　　由于远程开发需要部署一台测试服务器，在服务器上运行substrate实例后，接着需要部署测试合约，供同事调试使用。<a id="more"></a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　从github上取回节前提交的代码，开始使用<code>cargo contract build</code>编译。在编译的过程中出现问题依赖文件不存在的的错误，出于以前调试substrate合约的经验，估计是依赖源码升级造成的。习惯性的先升级合约编译工具cargo-contract,从0.1.1升级到0.3.0，升级后继续编译，继续提示依赖的源码在依赖库不存在，这下反应过来了，他们最近又是大升级，变化比较大。刚开始还想把依赖项改成最新版的，经过一番尝试后，发现短时间内改不好，只有放弃。最后才想到在依赖库中指定提交的版本（增加rev+提交版本号），同时把使用的cargo-contract编译工具也还原到0.1.1版本，接着再编译修改后的合约项目，出现如下错误提示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">error: failed to run custom build <span class="built_in">command</span> <span class="keyword">for</span> `clear_on_drop v0.2.3`</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">  process didn<span class="string">'t exit successfully: `/home/ming/work/temp/diamond/target/release/build/clear_on_drop-b2b3a807da34adf1/build-script-build` (exit code: 1)</span></span><br><span class="line"><span class="string">--- stdout</span></span><br><span class="line"><span class="string">TARGET = Some("wasm32-unknown-unknown")</span></span><br><span class="line"><span class="string">OPT_LEVEL = Some("z")</span></span><br><span class="line"><span class="string">HOST = Some("x86_64-unknown-linux-gnu")</span></span><br><span class="line"><span class="string">CC_wasm32-unknown-unknown = None</span></span><br><span class="line"><span class="string">CC_wasm32_unknown_unknown = None</span></span><br><span class="line"><span class="string">TARGET_CC = None</span></span><br><span class="line"><span class="string">CC = None</span></span><br><span class="line"><span class="string">CFLAGS_wasm32-unknown-unknown = None</span></span><br><span class="line"><span class="string">CFLAGS_wasm32_unknown_unknown = None</span></span><br><span class="line"><span class="string">TARGET_CFLAGS = None</span></span><br><span class="line"><span class="string">CFLAGS = None</span></span><br><span class="line"><span class="string">CRATE_CC_NO_DEFAULTS = None</span></span><br><span class="line"><span class="string">DEBUG = Some("false")</span></span><br><span class="line"><span class="string">running: "clang" "-Oz" "-ffunction-sections" "-fdata-sections" "-fPIC" "--target=wasm32-unknown-unknown" "-Wall" "-Wextra" "-o" "/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o" "-c" "src/hide.c"</span></span><br><span class="line"><span class="string">cargo:warning=error: unable to create target: '</span>No available targets are compatible with this triple.<span class="string">'</span></span><br><span class="line"><span class="string">cargo:warning=1 error generated.</span></span><br><span class="line"><span class="string">exit code: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--- stderr</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error occurred: Command "clang" "-Oz" "-ffunction-sections" "-fdata-sections" "-fPIC" "--target=wasm32-unknown-unknown" "-Wall" "-Wextra" "-o" "/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o" "-c" "src/hide.c" with args "clang" did not execute successfully (status code exit code: 1).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">warning: build failed, waiting for other jobs to finish...</span></span><br><span class="line"><span class="string">error: build failed</span></span><br><span class="line"><span class="string">error: Build failed</span></span><br></pre></td></tr></table></figure><p>看到这个错误，印象中是跟依赖库中<code>sp-core</code>、<code>sp-io</code> 是否使用 <code>std</code> features 相关，于是把这两个依赖项中的features取消掉，去掉后编译，出现错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">error[E0152]: found duplicate lang item `panic_impl`</span><br><span class="line">   --&gt; /home/ming/.cargo/git/checkouts/substrate-<span class="number">7e08433</span>d4c370a21/b443dda/primitives/io/src/lib.rs:<span class="number">864</span>:<span class="number">1</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">864</span> | / <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;core::panic::PanicInfo) -&gt; ! &#123;</span><br><span class="line"><span class="number">865</span> | |     <span class="keyword">unsafe</span> &#123;</span><br><span class="line"><span class="number">866</span> | |         <span class="keyword">let</span> message = sp_std::alloc::<span class="built_in">format!</span>(<span class="string">"&#123;&#125;"</span>, info);</span><br><span class="line"><span class="number">867</span> | |         logging::log(LogLevel::Error, <span class="string">"runtime"</span>, message.as_bytes());</span><br><span class="line"><span class="number">868</span> | |         core::intrinsics::abort()</span><br><span class="line"><span class="number">869</span> | |     &#125;</span><br><span class="line"><span class="number">870</span> | | &#125;</span><br><span class="line">    | |_^</span><br><span class="line">    |</span><br><span class="line">    = note: the lang item is first defined <span class="keyword">in</span> <span class="keyword">crate</span> `std` (which `parity_scale_codec` depends on)</span><br><span class="line"></span><br><span class="line">error[E0152]: found duplicate lang item `oom`</span><br><span class="line">   --&gt; /home/ming/.cargo/git/checkouts/substrate-<span class="number">7e08433</span>d4c370a21/b443dda/primitives/io/src/lib.rs:<span class="number">875</span>:<span class="number">1</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">875</span> | / <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">oom</span></span>(_: core::alloc::Layout) -&gt; ! &#123;</span><br><span class="line"><span class="number">876</span> | |     <span class="keyword">unsafe</span> &#123;</span><br><span class="line"><span class="number">877</span> | |         logging::log(LogLevel::Error, <span class="string">"runtime"</span>, <span class="string">b"Runtime memory exhausted. Aborting"</span>);</span><br><span class="line"><span class="number">878</span> | |         core::intrinsics::abort();</span><br><span class="line"><span class="number">879</span> | |     &#125;</span><br><span class="line"><span class="number">880</span> | | &#125;</span><br><span class="line">    | |_^</span><br><span class="line">    |</span><br><span class="line">    = note: the lang item is first defined <span class="keyword">in</span> <span class="keyword">crate</span> `std` (which `parity_scale_codec` depends on)</span><br><span class="line"></span><br><span class="line">error: aborting due to <span class="number">2</span> previous errors</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0152`.</span><br><span class="line">error: could not compile `sp-io`.</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">  process didn<span class="symbol">'t</span> exit successfully: `rustc --<span class="keyword">crate</span>-name sp_io --edition=<span class="number">2018</span> /home/ming/.cargo/git/checkouts/substrate-<span class="number">7e08433</span>d4c370a21/b443dda/primitives/io/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --<span class="keyword">crate</span>-<span class="class"><span class="keyword">type</span> <span class="title">lib</span></span> --emit=dep-info,metadata,link -C opt-level=z -C panic=abort -C overflow-checks=on -C metadata=<span class="number">1603</span>ab4b0f5657bd -C extra-filename=-<span class="number">1603</span>ab4b0f5657bd --out-dir /home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps --target wasm32-unknown-unknown -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/release/deps --<span class="keyword">extern</span> hash_db=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libhash_db-<span class="number">2</span>a1247b66dab3f2e.rmeta --<span class="keyword">extern</span> codec=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libparity_scale_codec-<span class="number">97</span>d1d02b4b85917a.rmeta --<span class="keyword">extern</span> sp_core=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_core-ab9564e391d6b38c.rmeta --<span class="keyword">extern</span> sp_runtime_interface=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_runtime_interface-<span class="number">2</span>c02a210bd05a2c8.rmeta --<span class="keyword">extern</span> sp_std=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_std-e4cf72917021ed6f.rmeta --cap-lints allow -C <span class="symbol">'link</span>-args=-z stack-size=<span class="number">65536</span> --import-memory'` (exit code: <span class="number">1</span>)</span><br><span class="line">warning: build failed, waiting <span class="keyword">for</span> other jobs to finish...</span><br><span class="line">error: build failed</span><br><span class="line">error: Build failed</span><br></pre></td></tr></table></figure><p>看到这个错误，知道不是依赖项features的原因，毕竟以前是调试通过的，接着又到github上查看clear_on_drop项目相关issue,发现有人问了类似的问题，从回复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">According to the error message, the issue is that your C compiler (in this case, clang) does not know the wasm32-unknown-unknown target. That is not something which could be fixed by this crate.</span><br></pre></td></tr></table></figure><p>里面提到可能是clang的原因，一直到这里我都还没有反应过来问题出在哪里。在继续折腾一番后，鉴于到了该洗漱睡觉的时间了，就想到明天再弄吧。在洗漱的过程中想起以前在公司调试的时候也是出现过类似的问题，也花了很长时间都没有排查出来原因，因为在同事的电脑上能够正常编译，所以排除了代码出错，猜测大概率是编译环境的原因，同事使用的是ubuntu 19.10,我使用的是18.04，最后是直接重新安装系统解决这个编译问题（之前就对当前的系统不满意，算是一次性全部把这些问题解决吧）。接着查看家里电脑的系统版本号，居然还是ubuntu 18.04(印象中重装过一次系统)，看到这个版本号后，心里面顿时轻松了些，知道这个问题可以怎么解决了。给我的选择是重装系统（肯定会解决问题）还是尝试先升级<code>llvm</code>、<code>clang</code>版本(不一定能够解决这个问题)。最后还是想尝试升级<code>clang</code>版本号，毕竟家里面的电脑各种开发环境、工具折腾起来需要费不少精力。</p><h2 id="升级clang"><a href="#升级clang" class="headerlink" title="升级clang"></a>升级clang</h2><p>　　在网上查看一下<code>llvm</code>相关介绍后，了解这个属于编译系统比较底层的工具库，里面包含很多系统编译需要的工具，使用命令<code>clang --version</code>查看了当前的clang版本为6.0，跟github上llvm 的10.0 bate版本差距已经比较大了。编译llvm的过程并不顺利，在生成Makefile过程中没有添加参数，造成后续编译过程很慢，耗时很长，最后也没有编译完全（没有耐心等下去了）。在短暂的放弃后，最后按照<a href="https://clang.llvm.org/get_started.html" target="_blank" rel="noopener">帮助文档</a>设置编译条件<code>cmake -DLLVM_ENABLE_PROJECTS=clang -G &quot;Unix Makefiles&quot; ../llvm</code>，在Makefile生成完后使用<code>make -j8</code>很快的就编译结束，最后使用<code>sudo make install</code>,使用<code>clang --version</code> 查看了最新版本为11.0.0,完成了clang升级。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>　　在clang 升级后，使用<code>cargo clean</code>将合约项目所有的以前编译的结果全部清除掉，使用<code>cargo contract build</code>重新编译合约，在经过几分钟的紧张时间后，看到wasm文件正确的编译出来了，心里面顿时轻松了，最后使用<code>cargo contract generate-metadata</code>编译合约ABI文件(metadata.json)，算是把折腾一天的问题给解决了。同时算是把系统编译环境做了一次更新，以后在编译中不会出现类似错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在以后的开发中，若存在需要直接引用github上的项目源码，需要加上版本号，使用<code>branch</code>、<code>tag</code>、<code>rev</code>等字段；</li><li>在安装三方库的时候，查看官方文档时要仔细，把里面提到的注意事项读完。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> substrate </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用github搭建自己的blog</title>
      <link href="/archives/b7d807be.html"/>
      <url>/archives/b7d807be.html</url>
      
        <content type="html"><![CDATA[<p>　　关于搭建blog的想法已经有很长时间了，虽然现在已经有成熟的框架能够快速搭建自己的blog服务，但是由于自己执行力的原因，一直没有实施。<a id="more"></a>由于这次疫情原因在家休假时间比较长，终于完成了这一项任务。现将自己的操作过程记录一下。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>　　针对类似blog这种服务，现在有很多现成的免费服务可用，比如传统的博客园、CSDN提供的博客服务，以及最近几年出现的简书、知乎专栏、掘金等应用，都能满足大多数人记录文字的需求。或许是出于性格原因，我更想拥有一个自己的域名，自己完全能够控制的站点，所以排除了在以上提到的服务中选择的可能性。<br>　　刚开始考虑过购买VPS服务来实现，但是想到我现阶段的使用目的只是单纯记录我在后续工作、生活中的一些事情，也不追求访问速度，<a href="https://help.github.com/cn/github/working-with-github-pages" target="_blank" rel="noopener">Github Pages</a>服务可以满足我的需求（其中一个主要原因是Github Pages可以<strong>免费</strong>提供静态站点服务）。<br>在确定好服务端之后，接着就是考虑内容生成工具，在网上查了一圈之后,从所需要准备的环境，以及内容编写工具以及维护程度等方面来考虑，最后还是选择<strong>Hexo</strong>。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>　　由于自己的电脑上已经有nodejs、git等hexo所需要的工具，所以在搭建的过程中很快速，步骤也很简单（但是自己还是折腾了好长时间，后面再述），首先使用命令<code>npm install -g hexo-cli</code>安装好hexo基础环境，可执行程序。关于hexo教程可以到<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">这里</a>学习。在基础环境齐全之后，操作如下命令：</p><ul><li><code>hexo init &quot;project name&quot;</code>，创建一个Hexo项目，后续的操作都在这个项目文件夹里面进行；</li><li><code>hexo new [layout] &quot;title&quot;</code>，创建一个文档，后续编写blog内容都可以通过这个命令来创建对应的md文件;默认情况下，创建的文档位于<code>source/_posts/</code>路径下；</li><li><code>hexo generate</code> 将该项目下的文档生成静态网页，生成内容位于<code>public</code>目录下；</li><li><code>hexo server</code> 启动一个本地服务，默认访问地址为<code>http://localhost:4000/</code>，可以通过该地址的内容进行预览；<br>通过上面几步，一个blog的内容生成，预览基本上就完成了，但是我们还需要将生成的内容上传到github仓库中。通过Github Pages介绍我们知道，要想启用这个服务，我们需要在自己的github仓库中创建一个 “user”.github.io的项目，然后将public中的内容上传到该项目中即可。<br>为方便上传内容到github，需要安装插件<code>npm install hexo-deployer-git</code>，同时在打开根目录中的_config.yml文件，在文档最后部分<code># Deployment</code>增加如下配置，<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:jeremymj/jeremymj.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>其中repo为将要上传的路径，为减少上传代码时需要输入github用户名、密码，我在这里使用了ssh方式上传，使用https方式也是可以的。在完成上述配置后，就可以使用命令<code>hexo deploy</code>将代码上传到github对应仓库中。<h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2>　　在通过以上几个步骤的操作，正常情况下在浏览器中输入地址项目地址，比如我的:jeremymj.github.io,就可以打开blog的首页。但是假如我们不想使用这个项目地址访问blog，则我们可以为我们的blog绑定一个自己的域名。关于域名的购买，自己随便选择一个服务商就行。在域名中增加一条CNAME解析，eg：<code>CNAME    www.jspace.top    jeremymj.github.io</code>,不同的DNS服务商这里显示根式有所区别。正常情况下，一段时间后就可以通过配置的域名访问我们的blog了。<h3 id="支持https访问"><a href="#支持https访问" class="headerlink" title="支持https访问"></a>支持https访问</h3>　　现在github pages服务直接支持https服务，默认情况下使用<code>xxx.github.io</code>的方式访问，直接是https方式。针对自定义的域名路径，支持https也不再需要通过中间代理就可以直实现。操作方式也很方便，在我们创建的github.io项目仓库中找到<code>Settings</code>选项，找到<code>GitHub Pages</code>设置模块，在<code>Custom domain</code>中填上我们自定义的域名，选中<code>Enforce HTTPS</code> 选项即可。为了是刚才的配置生效，我们还需要到为我们的域名在家几条<code>A</code>类型记录，<strong>主机记录</strong>这个字段，在有些服务商的配置文件中是填写<code>@</code>,有些服务商直接不支持<code>@</code>类型的则这个字段不用填写，保持默认即可。对应的值为<code>185.199.108.153</code>、<code>185.199.109.153</code>、<code>185.199.110.153</code>、<code>185.199.111.153</code>中的任意一个，这里我增加了4条<code>A</code>类型记录。配置好后，正常情况下，一段时间后就可以通过我们自定义的域名使用https访问我们的blog。<h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2>　　选择hexo做为blog的内容生成工具，是因为它有很多<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题模板</a>供我们使用。我在尝试了几个主题后，考虑到github提供的服务在国内访问速度的问题，最后还是使用的一个大家用的比较多的next模板，主题的替换很简单，在项目的根目录下使用命令:<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>,将主题模板取回来放置在themes文件夹下，如果要启用该模板，修改项目文件夹下_config.yml文件<strong>theme</strong>字段，值设置为：next。剩下的就是修改next文件下的配置文件，启用该主题的各种样式效果。<h2 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h2>　　为后续代码管理以及编写文档的保存，需要把项目上传到github管理，这里存在一个发布后的文件和源文件。根据我们在<a href="#搭建过程">搭建过程</a>中对_config.yml的设置，我们把发布后的文件保存在项目的master分支，则针对源文件就上传到该项目下一个分支来保存。在项目根目录下使用命令<code>git init</code>将该项目转换为git管理项目，添加远程仓库地址<code>git remote add origin git@github.com:jeremymj/jeremymj.github.io.git</code>，创建<code>.gitignore</code>文件，选择哪些文件不需要上传到github来管理。接着我们开始创建分支gh_dev，使用命令<code>git branch gh_dev</code>,使用命令<code>git push origin gh_dev</code>则可以把源文件提交到远程分支来管理。<strong>以后的操作都在本地分支gh_dev来完成,在编辑完成后通过hexo deploy发布到远端mater即可</strong><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2>　　这里列一些在搭建的过程中遇到的问题:<h3 id="cb-never-called"><a href="#cb-never-called" class="headerlink" title="cb() never called"></a>cb() never called</h3>　　在使用npm 方式来安装hexo 可执行程序时，遇到速度很慢的问题，但是在我的环境里面启用了自动代理，照理说应该会走代理的，就使用命令<code>npm config set proxy=http://127.0.0.1:1080</code>配置代理，后面拉取代码的速度果然有明显的提升，但是在拉取代码的过程中，出现错误提示，<code>cb() never called</code>。最后进入项目目录尝试使用<code>npm install</code> 获取刚才没有拉下来的代码，也是出现错误提示，在一篇帖子的提醒下，想起在配置代理的时候，当时查看的那个网页上给出的教程是 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> proxy=http://127.0.0.1:8087</span><br><span class="line">npm config <span class="built_in">set</span> registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure>但是我想到只需要proxy,就没有配置registry,在添加好registry后，再次使用<code>npm install</code>，<strong>cb() never called！</strong>没有再次出现了，对于出现这个问题的原因，猜测是在默认情况下，npm在执行过程中会有默认registry。我在添加代理的过程中只指定了proxy,系统不再使用默认的registry，对于这个猜测，感觉也不合理，没有道理在用户没有指定registry时，不使用默认registry！由于现在没有对应环境来验证，先在这里记录一下。<h3 id="自定义域名失效"><a href="#自定义域名失效" class="headerlink" title="自定义域名失效"></a>自定义域名失效</h3>　　在测试的过程中，发现在使用<code>hexo deploy</code>后，有时会存在自定义域名不生效，需要在Settings界面重新设置。最后在源文件目录(本地gh_dev分支)中增加一个CNAME配置文件，在配置文件中填写<code>www.jspace.top</code>即可以解决这个问题<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>　　以上就是使用hexo搭建blog的过程，关于使用next主题配置的操作，也不再详细说，里面的配置项很多，针对配置项不能够满足我们对效果期望的地方，可以直接修改对应的css文件。关于样式的美化，需要花费的时间比较多，后续再慢慢的优化，至少目前是有一个地方，可以记录自己的学习笔记。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
