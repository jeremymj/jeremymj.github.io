<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ethereum合约调用</title>
    <url>/archives/5618e610.html</url>
    <content><![CDATA[<p>在<a href="https://www.jspace.top/archives/ed176158.html">ethereum交易签名</a>中总结了以太坊交易的构成方式，不论是合约调用还是普通的<code>ETH</code>转账交易，交易的构造方式都是一样的。<a id="more"></a>在转ETH的交易的中，目标地址<code>to</code>是我们将要转入的账户地址，针对合约调用，目标地址<code>to</code>是我们将要调用合约的地址。要构造出这两种交易，关键是交易中<code>data</code>字段的构造；</p>
<h2 id="ETH转账交易data构造"><a href="#ETH转账交易data构造" class="headerlink" title="ETH转账交易data构造"></a>ETH转账交易data构造</h2><p>根据以太坊开发文档，我们可以在ETH转账的时候填写一定长度的附加信息做为本次交易的备注信息。在钱包转账交易中，只需要将用户填写的备注信息转换为<code>Vec&lt;u8&gt;</code>格式并将结果赋值给<code>data</code>字段即可；当交易成功后，可以在<a href="https://etherscan.io/" target="_blank" rel="noopener">etherscan</a>中查询到当次交易添加的备注信息。</p>
<h2 id="合约调用data字段构造"><a href="#合约调用data字段构造" class="headerlink" title="合约调用data字段构造"></a>合约调用data字段构造</h2><p>当交易为合约调用时，data字段的内容将来至于两部分，其中是一部分数据来自于合约调用方法编码，另外一部分数据来至于交易的备注信息。通过这种方式实现了用户在合约调用时，添加备注信息的需求。他们的构造关系如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合约方法、参数编码</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> encode_data = ethtx::get_erc20_transfer_data(to_account, amount)?;</span><br><span class="line">    <span class="comment">//添加合约交易备注信息</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(addition_str) = user_input&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> addition =addition_str.as_bytes().to_vec();</span><br><span class="line">    encode_data.append(&amp;<span class="keyword">mut</span> addition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示用户在调用erc20合约转账方法时参数拼接方式。其中<code>get_erc20_transfer_data</code>主要功能是通过调用如下代码实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">encode_contract_input</span></span>&lt;P&gt;(&amp;<span class="keyword">self</span>, method: &amp;<span class="built_in">str</span>, params: P) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;, error::Error&gt; <span class="keyword">where</span> P: contract::tokens::Tokenize &#123;</span><br><span class="line">       <span class="keyword">let</span> data = <span class="keyword">self</span>.abi.function(method).and_then(|function| &#123;</span><br><span class="line">           function.encode_input(&amp;params.into_tokens())</span><br><span class="line">       &#125;)?;</span><br><span class="line">       <span class="literal">Ok</span>(data)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面内容重点描述<code>encode_contract_input</code>实现原理。</p>
<h2 id="合约方法、参数编码"><a href="#合约方法、参数编码" class="headerlink" title="合约方法、参数编码"></a>合约方法、参数编码</h2><p>当需要进行合约调用时，我们需要获取目标合约对应的<code>ABI</code>文件，<code>ABI</code>文件中有关于合约方法、所需参数以及参数类型的描述，通过一系列编码规则，最终会得到我们所需要的目标数据。整个编码数据是将<strong>方法编码</strong>和<strong>参数编码</strong>两部分参数组合起来的字节数组。使用下面的合约来详细说明编码的过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; r &#x3D; x &gt; 32 || y; &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法编码"><a href="#方法编码" class="headerlink" title="方法编码"></a>方法编码</h3><p>获取将要调用方法对应的签名，以方法<code>baz</code>为例，它对应的函数签名为<code>baz(uint32,bool)</code>，对函数使用<code>Keccak</code>算法做<code>Hash</code>运算，取运算结果的前4个字节作为标识符来代表将要调用的方法。<br>关键代码如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fill_signature</span></span>(name: &amp;<span class="built_in">str</span>, params: &amp;[ParamType], result: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) &#123;</span><br><span class="line">	<span class="keyword">let</span> types = params.iter().map(Writer::write).collect::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;().join(<span class="string">","</span>);</span><br><span class="line">	<span class="keyword">let</span> data: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; = <span class="built_in">From</span>::from(<span class="built_in">format!</span>(<span class="string">"&#123;&#125;(&#123;&#125;)"</span>, name, types).as_str());</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> sponge = Keccak::new_keccak256();</span><br><span class="line">	sponge.update(&amp;data);</span><br><span class="line">	sponge.finalize(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对<code>baz(uint32,bool)</code>的计算结果为<code>0xcdcd77c0</code>。（这里取前4个字节的原因估计在定义的合约方法中有足够大的概率避免hash冲突又能节省空间）。</p>
<h3 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h3><p>与方法编码相比较，数据编码就显得复杂的多。在合约参数定义中，存在静态类型数据和动态类型，这里将<code>uint&lt;M&gt;、int&lt;M&gt;,bool，address</code>定义为静态类型，其中<code>0 &lt; M &lt;= 256&amp;&amp;M % 8 == 0</code>代表暂用的字节数；动态数据类型定义比如：bytes、string、T[]、T[k]、(T1,…,Tk)，其中T为任意类型；<br>针对静态类型除<code>address</code>占用20字节外，另外的静态类型都用32字节表示，通过在左边补零的方式补齐。<br>以调用baz方法，传入参数<code>69</code>，<code>true</code>为例；</p>
<ul>
<li>69 编码为十六进制为0x45,通过移位补齐32字节的方式，最后编码的结果为：<code>0x0000000000000000000000000000000000000000000000000000000000000045</code>；</li>
<li>true,最后编码的结果的为<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>；<br>所以针对<code>baz(69,true)</code>最后编码出来的结果的为：<code>0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</code>；</li>
</ul>
<p>针对同时包含动态类型和静态类型的方法，遵循<code>静态数据直接编码存放</code>，动态类型数据<code>存放位置索引</code>，通过<strong>索引来指示实际的编码数据</strong>。<br>以编码<code>sam</code>方法为例: <code>sam(&quot;dave&quot;, true 、[1,2,3])</code>,该方法中包含两个动态类型，针对第一个参数，先传入真实数据的索引位置，是从第<code>96</code>(后面有详细的计算说明为什么是这个数)个字节位置开始，计算规则如下：</p>
<ul>
<li>第一个参数索引位置表示 占32字节；</li>
<li>第二个参数为静态类型，直接表示为<code>0x0000000000000000000000000000000000000000000000000000000000000001</code>，占用32个字节；</li>
<li>第三个参数，为动态类型，直接使用32个字节表示索引。</li>
</ul>
<p>因此第一个参数的真实数据是从(32+32+32 = 96)位置开始的。将所有的参数都表示完后，后面就开始添加动态类型数据。因为动态类型数据长度是动态变化的，所以真实数据开始前还需要有长度声明的字段，这个字段也是32字节的大小；</p>
<ul>
<li>“dave”的长度为4，编码后的数据为<code>0x0000000000000000000000000000000000000000000000000000000000000004</code>；</li>
<li>针对<code>dave</code>直接转换为十六进制为<code>0x64617665</code>，不满足<strong>32字节</strong>的大小，在后续通过补零的方式补齐，最后的编码的结果为<code>0x6461766500000000000000000000000000000000000000000000000000000000</code>;</li>
<li>通过上面的描述，能够计算出来第三个参数的其实位置索引为：(96+64=160),即编码后的数据为<code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>,</li>
<li><code>[1,2,3]</code>是动态类型数据，先编码数组的长度为<code>0x0000000000000000000000000000000000000000000000000000000000000003</code>；</li>
</ul>
<p>数组中对应的成员对应的编码分别为</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>;</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>;</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>;</li>
</ul>
<p>综合上面的编码数据，<code>sam(&quot;dave&quot;, true 、[1,2,3])</code>最后编码的结果为<code>0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</code></p>
<p>通过上面合约方法、参数编码的介绍，将编码后的结果与用户的备注信息拼接，就完成了构造交易结构中<code>data</code>字段的构造。在上述编码的过程中，我们可以发现它的编码规则，当编码的数据为<strong>字符串类型</strong>时，数据直接通过<strong>右补零</strong>的方式补齐32字节的大小，当数据为<strong>数值型</strong>时，是通过在左边添加零偏移的方式补齐32字节大小空间。关于合约编码更详细的内容可以参考<a href="https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html" target="_blank" rel="noopener">文档</a>.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在最近开发钱包过程中，这部分的功能已经编码结束已经有一段时间了，当时为了实现在转ERC20时同时实现交易备注信息的添加，在网上查了相关资料都没有看到文档说明怎么来处理合约调用编码数据与用户备注信息的关系，今天算是对这部分知识的复习。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
        <tag>合约数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title>ethereum交易签名</title>
    <url>/archives/ed176158.html</url>
    <content><![CDATA[<p>　　今天把前段在实现ETH交易过程中遇到的问题做一下记录，算是对这部分知识的复习。要想在以太坊中完成一笔交易，可以借助节点对外开放的<code>eth_sendTransaction</code>或<code>eth_sendRawTransaction</code>这两个JsonRpc接口。<a id="more"></a>我们只需要拼接好这个接口需要的参数再通过网络提交到节点即可。本文的重点是叙述怎么来拼接这个目标参数，由于在钱包开发中主要使用<code>eth_sendRawTransaction</code>这个接口，下面就对这接口所需要的参数进行阐述。</p>
<h2 id="交易构造"><a href="#交易构造" class="headerlink" title="交易构造"></a>交易构造</h2><p>　　通过查阅Ethereum的文档，知道构造原始交易所需要的结构如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Description of a Transaction, pending or in the chain.</span></span><br><span class="line"><span class="meta">#[derive(Debug, Default, Clone, PartialEq, Deserialize, Serialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">RawTransaction</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Nonce</span></span><br><span class="line">    <span class="keyword">pub</span> nonce: U256,</span><br><span class="line">    <span class="comment">/// Recipient (None when contract creation)</span></span><br><span class="line">    <span class="keyword">pub</span> to: <span class="built_in">Option</span>&lt;H160&gt;,</span><br><span class="line">    <span class="comment">/// Transfered value</span></span><br><span class="line">    <span class="keyword">pub</span> value: U256,</span><br><span class="line">    <span class="comment">/// Gas Price</span></span><br><span class="line">    <span class="meta">#[serde(rename = <span class="meta-string">"gasPrice"</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> gas_price: U256,</span><br><span class="line">    <span class="comment">/// Gas amount</span></span><br><span class="line">    <span class="keyword">pub</span> gas: U256,</span><br><span class="line">    <span class="comment">/// Input data</span></span><br><span class="line">    <span class="keyword">pub</span> data: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：自己在实现过程中定义原始交易参数结构体时，必须要确保<strong>参数顺序相同</strong>。在构造交易时会将该结构体使用RLP方式编码，当节点收到原始交易时会按照这个结构对收到的数据做编码还原；<br>从<code>RawTransaction</code>我们知道在一笔交易中涉及到<code>nonce</code>,<code>to</code>，<code>value</code>,<code>gas_price</code>,<code>gas,data</code>这五个属性。这下面是对这些属性的说明：</p>
<h3 id="nonce"><a href="#nonce" class="headerlink" title="nonce"></a>nonce</h3><p>　　在区块链交易中都需要有nonce这个参数，用于表示当前发送地址的第几笔交易，能够确保交易的顺序，防止节点被交易重放攻击。注意：</p>
<ul>
<li>初始交易是从编号0开始的，可以通过调用<code>eth_getTransactionCount</code>获取当前交易的值；</li>
<li>节点在验证交易时会校验当前的nonce是否为正确的值，若交易中的nonce值比真实值小，则这笔交易会直接返回nonce错误；</li>
<li>若交易中的nonce值比真实值大，则会将该交易放入一个<code>future</code>队列里面，等待中间缺失的交易进来后再继续验证这笔交易；<h3 id="地址-to"><a href="#地址-to" class="headerlink" title="地址(to)"></a>地址(to)</h3>　　<code>to</code>表示交易的接受地址，这个地址通常可以是一个外部地址（该地址对应的私钥有实际的控制者），表示一笔转账操作；也可以是一个内部地址(合约地址)，表示合约调用。<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3>　　这个值表示该交易需要转给目标地址的<code>ETH</code>数量，需要注意填写的数值是最小单位（wei）,通常在钱包界面上填写的数值单位是<code>ether</code>，在处理的时候需要做单位转换；这里有几种情况需要注意：</li>
<li>填写正常的数值且to 地址是一个外部地址，表示将指定数量的token转到指定地址；</li>
<li>填写的数值为0，且to地址是一个外部地址，这种操作除了浪费gas之外，没有任何作用；</li>
<li>当to地址是一个合约地址时且value不为空，这样的交易也会将发送者地址上的eth代币转到合约地址上，由于合约地址是内部地址，没人知道对应的私钥，所以这些token会成为死币；<h3 id="gas-price"><a href="#gas-price" class="headerlink" title="gas_price"></a>gas_price</h3>　　表示每个单位的gas值多少wei，我们知道Ethereum EVM在执行过程中每个操作都需要消耗gas,gas是一个<code>不随ETH波动而波动的单位定义</code>，用于表示调用者愿意为这笔交易每个步骤花费多少token，通常情况下调用者给出的<code>gas_price</code>价格越高，矿工会优先执行执行；为了防止恶意抬高gas_price，Ethereum针对<code>gas_price</code>有专门的算法来进行控制，开发者在构造交易的时候，直接调用节点提供的rpc接口<code>eth_gasPrice</code>即可；还需要注意的是，这里的数值也需要填写<strong>最小的单位wei</strong>。<h3 id="gas"><a href="#gas" class="headerlink" title="gas"></a>gas</h3>　　表示愿意交易在执行过程中，愿意支付的最大gas数量，也就是我们常见的gas_limit数值；若是指定的gas数量太少，交易在执行的过程中gas消耗完后，就会返回错误；若是指定的gas数量比较大，调用者账户上也有足够的gas可扣，则交易会正常的执行，在执行完后会将多余的gas返回到调用者的账户上。<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3>　　在以太坊中针对每笔交易都可以填写附加信息，针对这个字段的内容我打算放到下一篇关于合约调用的文章中。<br>以上部分就是构造一个以太坊交易所需要的基本数据，要是构造的交易能够在链上被虚拟机执行，还需要对交易进行签名操作；<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2>在以太坊中，数据的编码使用<code>RLP</code>的编码方式来进行的，关于编码实现的具体方式，可以查看<a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-RLP" target="_blank" rel="noopener">wiki</a>,只是需要注意在编码的过程中，需要注意字段的顺序</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对RawTransaction 数据使用RLP编码</span></span><br><span class="line">   <span class="function"><span class="keyword">fn</span> <span class="title">encode</span></span>(&amp;<span class="keyword">self</span>, rlp: &amp;<span class="keyword">mut</span> RlpStream) &#123;</span><br><span class="line">       rlp.append(&amp;<span class="keyword">self</span>.nonce);</span><br><span class="line">       rlp.append(&amp;<span class="keyword">self</span>.gas_price);</span><br><span class="line">       rlp.append(&amp;<span class="keyword">self</span>.gas);</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">ref</span> t) = <span class="keyword">self</span>.to &#123;</span><br><span class="line">           rlp.append(t);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           rlp.append(&amp;<span class="built_in">vec!</span>[]);</span><br><span class="line">       &#125;</span><br><span class="line">       rlp.append(&amp;<span class="keyword">self</span>.value);</span><br><span class="line">       rlp.append(&amp;<span class="keyword">self</span>.data);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>之所以按照<code>fn encode</code>方式将数据添加到<code>RlpStream</code>实例中，是因为节点验证交易时会进行如下方式的数据解码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//还原出原RLP数据格式</span></span><br><span class="line"><span class="keyword">impl</span> rlp::Decodable <span class="keyword">for</span> UnverifiedTransaction &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">decode</span></span>(d: &amp;Rlp) -&gt; <span class="built_in">Result</span>&lt;<span class="keyword">Self</span>, DecoderError&gt; &#123;</span><br><span class="line">		<span class="comment">//rlp编码 针对数据长度 是有特征？？</span></span><br><span class="line">		<span class="keyword">if</span> d.item_count()? != <span class="number">9</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">Err</span>(DecoderError::RlpIncorrectListLen);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">let</span> hash = keccak(d.as_raw());</span><br><span class="line">		<span class="literal">Ok</span>(UnverifiedTransaction &#123;</span><br><span class="line">			unsigned: Transaction &#123;</span><br><span class="line">				nonce: d.val_at(<span class="number">0</span>)?,</span><br><span class="line">				gas_price: d.val_at(<span class="number">1</span>)?,</span><br><span class="line">				gas: d.val_at(<span class="number">2</span>)?,</span><br><span class="line">				action: d.val_at(<span class="number">3</span>)?,</span><br><span class="line">				value: d.val_at(<span class="number">4</span>)?,</span><br><span class="line">				data: d.val_at(<span class="number">5</span>)?,</span><br><span class="line">			&#125;,</span><br><span class="line">			v: d.val_at(<span class="number">6</span>)?,</span><br><span class="line">			r: d.val_at(<span class="number">7</span>)?,</span><br><span class="line">			s: d.val_at(<span class="number">8</span>)?,</span><br><span class="line">			hash,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="签名生成"><a href="#签名生成" class="headerlink" title="签名生成"></a>签名生成</h2><p>　　以太坊使用Secp256k1算法来签名，我们知道签名都有计算源数据的hash值过程。针对交易hash值的计算过程如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hash</span></span>(&amp;<span class="keyword">self</span>, chain_id: <span class="built_in">Option</span>&lt;<span class="built_in">u64</span>&gt;) -&gt; [<span class="built_in">u8</span>; <span class="number">32</span>] &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mut</span> stream = RlpStream::new();</span><br><span class="line">      stream.begin_unbounded_list();</span><br><span class="line">      <span class="keyword">self</span>.encode(&amp;<span class="keyword">mut</span> stream);</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(n) = chain_id &#123;</span><br><span class="line">          stream.append(&amp;n);</span><br><span class="line">          stream.append(&amp;U256::zero());</span><br><span class="line">          stream.append(&amp;U256::zero());</span><br><span class="line">      &#125;</span><br><span class="line">      stream.finalize_unbounded_list();</span><br><span class="line">      keccak(stream.out().as_slice())</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>chain_id</code>表示当前交易用于的目标链，以太坊使用这个参数的目的是防止在不同的链上提交相同的数据，让节点不能提前检查出风险交易，增加了链的稳定性。可以通过构造<code>JsonRpc</code>请求数据<code>{&quot;method&quot;:&quot;eth_chainId&quot;,&quot;params&quot;:[],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}</code>获取到；<br>hash数据签名的过程如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ecdsa_sign</span></span>(hash: &amp;[<span class="built_in">u8</span>], private_key: &amp;[<span class="built_in">u8</span>], chain_id: <span class="built_in">u64</span>) -&gt; EcdsaSig &#123;</span><br><span class="line">    <span class="keyword">let</span> s = Secp256k1::signing_only();</span><br><span class="line">    <span class="keyword">let</span> msg = Message::from_slice(hash).unwrap();</span><br><span class="line">    <span class="keyword">let</span> key = SecretKey::from_slice(private_key).unwrap();</span><br><span class="line">    <span class="keyword">let</span> (v, sig_bytes) = s.sign_recoverable(&amp;msg, &amp;key).serialize_compact();</span><br><span class="line"></span><br><span class="line">    EcdsaSig &#123;</span><br><span class="line">        v: v.to_i32() <span class="keyword">as</span> <span class="built_in">u64</span> + chain_id * <span class="number">2</span> + <span class="number">35</span>,</span><br><span class="line">        r: sig_bytes[<span class="number">0</span>..<span class="number">32</span>].to_vec(),</span><br><span class="line">        s: sig_bytes[<span class="number">32</span>..<span class="number">64</span>].to_vec(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>签名最后得到的<code>v</code>、<code>r</code>、<code>s</code>值和交易结构体编码的数据一起构成了<code>eth_sendRawTransaction</code>这个接口所需要的数据；下面是完整的交易签名实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sign</span></span>(&amp;<span class="keyword">self</span>, private_key: &amp;[<span class="built_in">u8</span>], chain_id: <span class="built_in">Option</span>&lt;<span class="built_in">u64</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">       <span class="keyword">let</span> hash_data = <span class="keyword">self</span>.hash(chain_id);</span><br><span class="line">       <span class="keyword">let</span> sig = ecdsa_sign(&amp;hash_data, private_key, chain_id.unwrap());</span><br><span class="line">       <span class="keyword">let</span> <span class="keyword">mut</span> r_n = sig.r;</span><br><span class="line">       <span class="keyword">let</span> <span class="keyword">mut</span> s_n = sig.s;</span><br><span class="line">       <span class="keyword">while</span> r_n[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">           r_n.remove(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> s_n[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">           s_n.remove(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">let</span> <span class="keyword">mut</span> tx = RlpStream::new();</span><br><span class="line">       tx.begin_unbounded_list();</span><br><span class="line">       <span class="keyword">self</span>.encode(&amp;<span class="keyword">mut</span> tx);</span><br><span class="line">       tx.append(&amp;sig.v);</span><br><span class="line">       tx.append(&amp;r_n);</span><br><span class="line">       tx.append(&amp;s_n);</span><br><span class="line">       tx.finalize_unbounded_list();</span><br><span class="line">       tx.out()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>　　从上述代码可以看出，我们通常听到的交易签名，其实是包含了通过<code>keccak256</code>计算交易hash值、使用<code>Sec256K1</code>对Hash签名并将签名结果和交易详情编码在一起，最后输出<code>Hex</code>格式数据的过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　通过上面的描述详细说明了以太坊交易构成的过程，这也是当前钱包在构造用户交易的核心过程，该过程涉及到的内容很多，后续可以继续对里面的知识点进行阐述。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
        <tag>交易签名</tag>
        <tag>数据编码</tag>
      </tags>
  </entry>
  <entry>
    <title>ethereum钱包功能开发之环境搭建</title>
    <url>/archives/426a759f.html</url>
    <content><![CDATA[<p>　　最近在进行ethereum钱包功能的开发，在这里将实现钱包功能过程中遇到的问题进行记录。<a id="more"></a>从当前的进度来看，打算分为几篇文章来记录开发过程中的经历，算是对自己工作过程中进行一个记录与总结。</p>
<h2 id="常见工具介绍"><a href="#常见工具介绍" class="headerlink" title="常见工具介绍"></a>常见工具介绍</h2><p>　　在进行Ethereum平台相关内容开发时可能会看到<code>Geth</code>，<code>Mist</code>,<code>Truffle</code>,<code>Ganache</code>等，这里对他们的区别做一个简单区分：</p>
<ul>
<li>Geth:是Ethereum的一个客户端实现，用于节点搭建等，是使用golang来实现的；</li>
<li>Parity Ethereum,号称最快、最安全、最稳定的一个Ethereum客户端实现，是使用Rust来开发的；</li>
<li>Mist:是etherum官方出的一个区块链浏览器，能够让用于进行交易，合约调用等；</li>
<li>Truffle：简单的理解它是一个<strong>以太坊合约开发工具</strong>，它可以在智能合约开发、测试、发布等过程更方便，关于Truffle更多详细资料，<a href="">查看这里</a></li>
<li>Ganache：是一个为开发者提供的<strong>私有Ethereum 区块链客户端</strong>, 可以用于本地部署, 开发, 测试应用程序, 测试代码,<a href="https://truffleframework.org/docs/getting_started/client" target="_blank" rel="noopener">更多介绍查看这里</a><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2>　　为便于提供不同平台的支持，我们使用Rust来实现钱包底层的功能，借助Rust交叉编译的便捷性，能够很方便的编译出目标平台所需要的动态库。借助Flutter在界面上实现的跨平台技术，能够解决Andorid,IOS等平台的一致性问题。关于<a href="https://www.rust-lang.org/zh-CN/" target="_blank" rel="noopener">Rust</a>、<a href="https://flutter.dev/" target="_blank" rel="noopener">Flutter</a>的介绍可以点击链接进行了解，关于搭建Rust、Flutter交叉编译环境过程,可以<a href="https://dev.to/robertohuertasm/rust-once-and-share-it-with-android-ios-and-flutter-286o" target="_blank" rel="noopener">参考这篇文章</a>。本文重点对支持ethereum开发所需的环境搭建进行叙述。<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2>　　由于前期有开发<a href="https://substrate.dev/" target="_blank" rel="noopener">Substrate</a>的经验，知道ethereum与substrate来源的关系，开发过程中需要搭建一个节点来接收JsonRpc的请求。所以在ethereum钱包开发中也需要节点来参与调试。按照这种思路，我首先想到的是在本地直接运行一个ethereum节点，接入测试链或者搭建一个私链。由于使用Rust的原因，节点的选择上就自然的想到了Parity Ethereum（由于某些原因现在已经转移到<a href="https://discordapp.com/invite/JCuNu3m" target="_blank" rel="noopener">OpenEthereum DAO</a>）。<h2 id="节点程序编译"><a href="#节点程序编译" class="headerlink" title="节点程序编译"></a>节点程序编译</h2>　　从github上取回<a href="https://github.com/OpenEthereum/open-ethereum" target="_blank" rel="noopener">最新的代码</a>，进入项目的根目录，直接使用rust的编译命令<code>Cargo build --release</code>进行编译，等待几分钟之后就可以编译完成，编译生成的可执行程序在<code>./target/release/</code>目录下。直接运行<code>./parity</code>默认会启动一个全节点，会进行区块数据同步等操作，针对我们仅仅是想测试来说，不需要接入主网参与数据同步。<h3 id="可执行程序介绍"><a href="#可执行程序介绍" class="headerlink" title="可执行程序介绍"></a>可执行程序介绍</h3>在运行<code>./parity --help</code>后，可以看到程序支持的一些可选参数：</li>
<li>–jsonrpc-apis，可选的值有：all, safe, debug, web3, net, eth, pubsub, personal, signer, parity, parity_pubsub,parity_accounts, parity_set, traces, rpc, secretstore, shh, shh_pubsub.这些rpc接口不是在每个节点都对外开放的，节点的类型也很多，所以在开发的时候确保所选的节点有开放你所需要的rpc接口这点很重要，涉及到技术方案的选择以及实现难度、工作量等问题。</li>
<li>–chain=[CHAIN]，可选的值有poacore, tobalaba, expanse,musicoin, ellaism, mix, callisto, morden, ropsten, kovan, rinkeby,goerli, kotti, poasokol, testnet, or dev，根据需要启动的节点类型，指定对应的chain。</li>
<li>–bootnodes,这个值是需要接入的节点地址，每个节点启动的时候都会输出当前自身节点的地址，用于其他节点的直接连接，地址格式如下：<code>enode://xxxx@ip:port</code><br>　　除了跟启动参数外，<code>./parity</code>还提供很多工具命令，比如节点自身也具有钱包管理的功能，能够生成账户地址:运行<code>parity account new</code>，输入密码之后就会生成一个账户地址，同时该账户的私钥信息保存在<code>~/.local/share/io.parity.ethereum/keys/ethereum/</code>路径下。若是在启动节点的时候需要启用挖矿功能，则直接添加 <code>--author [地址]</code>，比如：<code>./parity --author 0037a6b811ffeb6e072da21179d11b1406371c63</code>,地址是去掉<code>0x</code>前缀的<h2 id="节点启动"><a href="#节点启动" class="headerlink" title="节点启动"></a>节点启动</h2>　　由于我仅仅是想测试依赖节点的Rpc服务来验证钱包拼接的数据结构是否满足接口要求，所以我使用的启动方式是使用<code>parity --config dev</code>启动ETH开发节点，同时该节点默认存在一个地址<code>0x00a329c0648769a73afac7f9381e08fb43dbea72</code>，对应的私钥为：<code>0x4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7</code>（这个私钥仅用于开发测试，正式使用时请保存好自己的私钥），该账户中存在一定数目的测试ETH　token，可以用于后续的开发测试。<h2 id="常用Rpc"><a href="#常用Rpc" class="headerlink" title="常用Rpc"></a>常用Rpc</h2>　　虽然有不同的类型的节点，但是他们都有eth开头的最基础Rpc接口，我们可以借助这些接口实现我们的交易数据提交等功能，以下列举出的常用接口使用方式：</li>
<li><code>eth_getTransactionCount</code>，熟悉区块链开发的都清楚每笔交易都需要一个nonce,用于避免交易的重放攻击，确保交易的执行顺序，在拼接交易之前需要获取交易发起方当前总共发起的交易数，比如<code>curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionCount&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39;  -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code></li>
<li><code>eth_sendRawTransaction</code>，用于构造离线交易签名，这种方式在钱包开发里面使用的场景比较多，需要依赖特定的节点就可以将交易提交到链上进行验证，这里稍微麻烦的是Rpc请求参数的构造，这在后面的文章做详细的介绍。该API请求数据格式:<code>curl --data &#39;{&quot;method&quot;:&quot;eth_sendRawTransaction&quot;,&quot;params&quot;:[&quot;0xf86d808253e8837a1200941c9baedc94600b2d1c8a6d2bad1744e6182f300e8609184e72a0008568656c6c6f29a0a65b500258e5cf458db262758786e5c327285c924df687b8e9ce28e2fccb9451a07359f8dba84300d950bb534ac71a8d0eccb2a7e01a8cb70041c886588424be1c&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code>。 </li>
<li><code>eth_getTransactionByHash</code>，在<code>eth_sendRawTransaction</code>的Rpc请求中会返回当前交易的结果。假如交易参数验证通过，会返回当前交易的hash，通过该Rpc可以查看该交易的具体详情，该API数据请求格式如下：<code>curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x1486d4ff14e7fc6f991c17633e2b7a65ae52fc7a1be33845773a561a6955929e&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code></li>
<li><code>eth_getBalance</code>，针对交易来说，比较重要的一个功能是查询指定地址上的ETH token数量,该API数据请求格式如下:<code>curl --data &#39;{&quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545</code><br>　　以上是在钱包开发中使用频率较高的一些RPC接口，关于parity Ethereum的介绍以及使用文档，可以查看<a href="https://wiki.parity.io/Parity-Ethereum" target="_blank" rel="noopener">这里</a>了解更多。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>　　以上就是使用Ethereum来实现钱包功能所需要了解的一些内容，关于用户账户、交易构成、合约调用等内容后续慢慢的更新。虽然前期有substrate开发的经验，但是在实现的过程中也遇到了一些问题，我想把遇到的问题记录下来，再把解决问题过程中查阅的内容消化后记录下来，算是自己的学习笔记，可以用于自己以后复习。</li>
</ul>
]]></content>
      <tags>
        <tag>Ethereum</tag>
        <tag>JsonRpc</tag>
      </tags>
  </entry>
  <entry>
    <title>编译出现clear_on_drop错误的解决过程</title>
    <url>/archives/1c5692ea.html</url>
    <content><![CDATA[<p>　　由于远程开发需要部署一台测试服务器，在服务器上运行substrate实例后，接着需要部署测试合约，供同事调试使用。<a id="more"></a></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　从github上取回节前提交的代码，开始使用<code>cargo contract build</code>编译。在编译的过程中出现问题依赖文件不存在的的错误，出于以前调试substrate合约的经验，估计是依赖源码升级造成的。习惯性的先升级合约编译工具cargo-contract,从0.1.1升级到0.3.0，升级后继续编译，继续提示依赖的源码在依赖库不存在，这下反应过来了，他们最近又是大升级，变化比较大。刚开始还想把依赖项改成最新版的，经过一番尝试后，发现短时间内改不好，只有放弃。最后才想到在依赖库中指定提交的版本（增加rev+提交版本号），同时把使用的cargo-contract编译工具也还原到0.1.1版本，接着再编译修改后的合约项目，出现如下错误提示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">error: failed to run custom build <span class="built_in">command</span> <span class="keyword">for</span> `clear_on_drop v0.2.3`</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">  process didn<span class="string">'t exit successfully: `/home/ming/work/temp/diamond/target/release/build/clear_on_drop-b2b3a807da34adf1/build-script-build` (exit code: 1)</span></span><br><span class="line"><span class="string">--- stdout</span></span><br><span class="line"><span class="string">TARGET = Some("wasm32-unknown-unknown")</span></span><br><span class="line"><span class="string">OPT_LEVEL = Some("z")</span></span><br><span class="line"><span class="string">HOST = Some("x86_64-unknown-linux-gnu")</span></span><br><span class="line"><span class="string">CC_wasm32-unknown-unknown = None</span></span><br><span class="line"><span class="string">CC_wasm32_unknown_unknown = None</span></span><br><span class="line"><span class="string">TARGET_CC = None</span></span><br><span class="line"><span class="string">CC = None</span></span><br><span class="line"><span class="string">CFLAGS_wasm32-unknown-unknown = None</span></span><br><span class="line"><span class="string">CFLAGS_wasm32_unknown_unknown = None</span></span><br><span class="line"><span class="string">TARGET_CFLAGS = None</span></span><br><span class="line"><span class="string">CFLAGS = None</span></span><br><span class="line"><span class="string">CRATE_CC_NO_DEFAULTS = None</span></span><br><span class="line"><span class="string">DEBUG = Some("false")</span></span><br><span class="line"><span class="string">running: "clang" "-Oz" "-ffunction-sections" "-fdata-sections" "-fPIC" "--target=wasm32-unknown-unknown" "-Wall" "-Wextra" "-o" "/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o" "-c" "src/hide.c"</span></span><br><span class="line"><span class="string">cargo:warning=error: unable to create target: '</span>No available targets are compatible with this triple.<span class="string">'</span></span><br><span class="line"><span class="string">cargo:warning=1 error generated.</span></span><br><span class="line"><span class="string">exit code: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--- stderr</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error occurred: Command "clang" "-Oz" "-ffunction-sections" "-fdata-sections" "-fPIC" "--target=wasm32-unknown-unknown" "-Wall" "-Wextra" "-o" "/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o" "-c" "src/hide.c" with args "clang" did not execute successfully (status code exit code: 1).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">warning: build failed, waiting for other jobs to finish...</span></span><br><span class="line"><span class="string">error: build failed</span></span><br><span class="line"><span class="string">error: Build failed</span></span><br></pre></td></tr></table></figure>
<p>看到这个错误，印象中是跟依赖库中<code>sp-core</code>、<code>sp-io</code> 是否使用 <code>std</code> features 相关，于是把这两个依赖项中的features取消掉，去掉后编译，出现错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0152]: found duplicate lang item `panic_impl`</span><br><span class="line">   --&gt; /home/ming/.cargo/git/checkouts/substrate-<span class="number">7e08433</span>d4c370a21/b443dda/primitives/io/src/lib.rs:<span class="number">864</span>:<span class="number">1</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">864</span> | / <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;core::panic::PanicInfo) -&gt; ! &#123;</span><br><span class="line"><span class="number">865</span> | |     <span class="keyword">unsafe</span> &#123;</span><br><span class="line"><span class="number">866</span> | |         <span class="keyword">let</span> message = sp_std::alloc::<span class="built_in">format!</span>(<span class="string">"&#123;&#125;"</span>, info);</span><br><span class="line"><span class="number">867</span> | |         logging::log(LogLevel::Error, <span class="string">"runtime"</span>, message.as_bytes());</span><br><span class="line"><span class="number">868</span> | |         core::intrinsics::abort()</span><br><span class="line"><span class="number">869</span> | |     &#125;</span><br><span class="line"><span class="number">870</span> | | &#125;</span><br><span class="line">    | |_^</span><br><span class="line">    |</span><br><span class="line">    = note: the lang item is first defined <span class="keyword">in</span> <span class="keyword">crate</span> `std` (which `parity_scale_codec` depends on)</span><br><span class="line"></span><br><span class="line">error[E0152]: found duplicate lang item `oom`</span><br><span class="line">   --&gt; /home/ming/.cargo/git/checkouts/substrate-<span class="number">7e08433</span>d4c370a21/b443dda/primitives/io/src/lib.rs:<span class="number">875</span>:<span class="number">1</span></span><br><span class="line">    |</span><br><span class="line"><span class="number">875</span> | / <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">oom</span></span>(_: core::alloc::Layout) -&gt; ! &#123;</span><br><span class="line"><span class="number">876</span> | |     <span class="keyword">unsafe</span> &#123;</span><br><span class="line"><span class="number">877</span> | |         logging::log(LogLevel::Error, <span class="string">"runtime"</span>, <span class="string">b"Runtime memory exhausted. Aborting"</span>);</span><br><span class="line"><span class="number">878</span> | |         core::intrinsics::abort();</span><br><span class="line"><span class="number">879</span> | |     &#125;</span><br><span class="line"><span class="number">880</span> | | &#125;</span><br><span class="line">    | |_^</span><br><span class="line">    |</span><br><span class="line">    = note: the lang item is first defined <span class="keyword">in</span> <span class="keyword">crate</span> `std` (which `parity_scale_codec` depends on)</span><br><span class="line"></span><br><span class="line">error: aborting due to <span class="number">2</span> previous errors</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0152`.</span><br><span class="line">error: could not compile `sp-io`.</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">  process didn<span class="symbol">'t</span> exit successfully: `rustc --<span class="keyword">crate</span>-name sp_io --edition=<span class="number">2018</span> /home/ming/.cargo/git/checkouts/substrate-<span class="number">7e08433</span>d4c370a21/b443dda/primitives/io/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --<span class="keyword">crate</span>-<span class="class"><span class="keyword">type</span> <span class="title">lib</span></span> --emit=dep-info,metadata,link -C opt-level=z -C panic=abort -C overflow-checks=on -C metadata=<span class="number">1603</span>ab4b0f5657bd -C extra-filename=-<span class="number">1603</span>ab4b0f5657bd --out-dir /home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps --target wasm32-unknown-unknown -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/release/deps --<span class="keyword">extern</span> hash_db=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libhash_db-<span class="number">2</span>a1247b66dab3f2e.rmeta --<span class="keyword">extern</span> codec=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libparity_scale_codec-<span class="number">97</span>d1d02b4b85917a.rmeta --<span class="keyword">extern</span> sp_core=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_core-ab9564e391d6b38c.rmeta --<span class="keyword">extern</span> sp_runtime_interface=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_runtime_interface-<span class="number">2</span>c02a210bd05a2c8.rmeta --<span class="keyword">extern</span> sp_std=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_std-e4cf72917021ed6f.rmeta --cap-lints allow -C <span class="symbol">'link</span>-args=-z stack-size=<span class="number">65536</span> --import-memory'` (exit code: <span class="number">1</span>)</span><br><span class="line">warning: build failed, waiting <span class="keyword">for</span> other jobs to finish...</span><br><span class="line">error: build failed</span><br><span class="line">error: Build failed</span><br></pre></td></tr></table></figure>
<p>看到这个错误，知道不是依赖项features的原因，毕竟以前是调试通过的，接着又到github上查看clear_on_drop项目相关issue,发现有人问了类似的问题，从回复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">According to the error message, the issue is that your C compiler (in this case, clang) does not know the wasm32-unknown-unknown target. That is not something which could be fixed by this crate.</span><br></pre></td></tr></table></figure>
<p>里面提到可能是clang的原因，一直到这里我都还没有反应过来问题出在哪里。在继续折腾一番后，鉴于到了该洗漱睡觉的时间了，就想到明天再弄吧。在洗漱的过程中想起以前在公司调试的时候也是出现过类似的问题，也花了很长时间都没有排查出来原因，因为在同事的电脑上能够正常编译，所以排除了代码出错，猜测大概率是编译环境的原因，同事使用的是ubuntu 19.10,我使用的是18.04，最后是直接重新安装系统解决这个编译问题（之前就对当前的系统不满意，算是一次性全部把这些问题解决吧）。接着查看家里电脑的系统版本号，居然还是ubuntu 18.04(印象中重装过一次系统)，看到这个版本号后，心里面顿时轻松了些，知道这个问题可以怎么解决了。给我的选择是重装系统（肯定会解决问题）还是尝试先升级<code>llvm</code>、<code>clang</code>版本(不一定能够解决这个问题)。最后还是想尝试升级<code>clang</code>版本号，毕竟家里面的电脑各种开发环境、工具折腾起来需要费不少精力。</p>
<h2 id="升级clang"><a href="#升级clang" class="headerlink" title="升级clang"></a>升级clang</h2><p>　　在网上查看一下<code>llvm</code>相关介绍后，了解这个属于编译系统比较底层的工具库，里面包含很多系统编译需要的工具，使用命令<code>clang --version</code>查看了当前的clang版本为6.0，跟github上llvm 的10.0 bate版本差距已经比较大了。编译llvm的过程并不顺利，在生成Makefile过程中没有添加参数，造成后续编译过程很慢，耗时很长，最后也没有编译完全（没有耐心等下去了）。在短暂的放弃后，最后按照<a href="https://clang.llvm.org/get_started.html" target="_blank" rel="noopener">帮助文档</a>设置编译条件<code>cmake -DLLVM_ENABLE_PROJECTS=clang -G &quot;Unix Makefiles&quot; ../llvm</code>，在Makefile生成完后使用<code>make -j8</code>很快的就编译结束，最后使用<code>sudo make install</code>,使用<code>clang --version</code> 查看了最新版本为11.0.0,完成了clang升级。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>　　在clang 升级后，使用<code>cargo clean</code>将合约项目所有的以前编译的结果全部清除掉，使用<code>cargo contract build</code>重新编译合约，在经过几分钟的紧张时间后，看到wasm文件正确的编译出来了，心里面顿时轻松了，最后使用<code>cargo contract generate-metadata</code>编译合约ABI文件(metadata.json)，算是把折腾一天的问题给解决了。同时算是把系统编译环境做了一次更新，以后在编译中不会出现类似错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>在以后的开发中，若存在需要直接引用github上的项目源码，需要加上版本号，使用<code>branch</code>、<code>tag</code>、<code>rev</code>等字段；</li>
<li>在安装三方库的时候，查看官方文档时要仔细，把里面提到的注意事项读完。</li>
</ul>
]]></content>
      <tags>
        <tag>substrate</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github搭建自己的blog</title>
    <url>/archives/b7d807be.html</url>
    <content><![CDATA[<p>　　关于搭建blog的想法已经有很长时间了，虽然现在已经有成熟的框架能够快速搭建自己的blog服务，但是由于自己执行力的原因，一直没有实施。<a id="more"></a>由于这次疫情原因在家休假时间比较长，终于完成了这一项任务。现将自己的操作过程记录一下。</p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>　　针对类似blog这种服务，现在有很多现成的免费服务可用，比如传统的博客园、CSDN提供的博客服务，以及最近几年出现的简书、知乎专栏、掘金等应用，都能满足大多数人记录文字的需求。或许是出于性格原因，我更想拥有一个自己的域名，自己完全能够控制的站点，所以排除了在以上提到的服务中选择的可能性。<br>　　刚开始考虑过购买VPS服务来实现，但是想到我现阶段的使用目的只是单纯记录我在后续工作、生活中的一些事情，也不追求访问速度，<a href="https://help.github.com/cn/github/working-with-github-pages" target="_blank" rel="noopener">Github Pages</a>服务可以满足我的需求（其中一个主要原因是Github Pages可以<strong>免费</strong>提供静态站点服务）。<br>在确定好服务端之后，接着就是考虑内容生成工具，在网上查了一圈之后,从所需要准备的环境，以及内容编写工具以及维护程度等方面来考虑，最后还是选择<strong>Hexo</strong>。</p>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>　　由于自己的电脑上已经有nodejs、git等hexo所需要的工具，所以在搭建的过程中很快速，步骤也很简单（但是自己还是折腾了好长时间，后面再述），首先使用命令<code>npm install -g hexo-cli</code>安装好hexo基础环境，可执行程序。关于hexo教程可以到<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">这里</a>学习。在基础环境齐全之后，操作如下命令：</p>
<ul>
<li><code>hexo init &quot;project name&quot;</code>，创建一个Hexo项目，后续的操作都在这个项目文件夹里面进行；</li>
<li><code>hexo new [layout] &quot;title&quot;</code>，创建一个文档，后续编写blog内容都可以通过这个命令来创建对应的md文件;默认情况下，创建的文档位于<code>source/_posts/</code>路径下；</li>
<li><code>hexo generate</code> 将该项目下的文档生成静态网页，生成内容位于<code>public</code>目录下；</li>
<li><code>hexo server</code> 启动一个本地服务，默认访问地址为<code>http://localhost:4000/</code>，可以通过该地址的内容进行预览；<br>通过上面几步，一个blog的内容生成，预览基本上就完成了，但是我们还需要将生成的内容上传到github仓库中。通过Github Pages介绍我们知道，要想启用这个服务，我们需要在自己的github仓库中创建一个 “user”.github.io的项目，然后将public中的内容上传到该项目中即可。<br>为方便上传内容到github，需要安装插件<code>npm install hexo-deployer-git</code>，同时在打开根目录中的_config.yml文件，在文档最后部分<code># Deployment</code>增加如下配置，<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:jeremymj/jeremymj.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
其中repo为将要上传的路径，为减少上传代码时需要输入github用户名、密码，我在这里使用了ssh方式上传，使用https方式也是可以的。在完成上述配置后，就可以使用命令<code>hexo deploy</code>将代码上传到github对应仓库中。<h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2>　　在通过以上几个步骤的操作，正常情况下在浏览器中输入地址项目地址，比如我的:jeremymj.github.io,就可以打开blog的首页。但是假如我们不想使用这个项目地址访问blog，则我们可以为我们的blog绑定一个自己的域名。关于域名的购买，自己随便选择一个服务商就行。在域名中增加一条CNAME解析，eg：<code>CNAME    www.jspace.top    jeremymj.github.io</code>,不同的DNS服务商这里显示根式有所区别。正常情况下，一段时间后就可以通过配置的域名访问我们的blog了。<h3 id="支持https访问"><a href="#支持https访问" class="headerlink" title="支持https访问"></a>支持https访问</h3>　　现在github pages服务直接支持https服务，默认情况下使用<code>xxx.github.io</code>的方式访问，直接是https方式。针对自定义的域名路径，支持https也不再需要通过中间代理就可以直实现。操作方式也很方便，在我们创建的github.io项目仓库中找到<code>Settings</code>选项，找到<code>GitHub Pages</code>设置模块，在<code>Custom domain</code>中填上我们自定义的域名，选中<code>Enforce HTTPS</code> 选项即可。为了是刚才的配置生效，我们还需要到为我们的域名在家几条<code>A</code>类型记录，<strong>主机记录</strong>这个字段，在有些服务商的配置文件中是填写<code>@</code>,有些服务商直接不支持<code>@</code>类型的则这个字段不用填写，保持默认即可。对应的值为<code>185.199.108.153</code>、<code>185.199.109.153</code>、<code>185.199.110.153</code>、<code>185.199.111.153</code>中的任意一个，这里我增加了4条<code>A</code>类型记录。配置好后，正常情况下，一段时间后就可以通过我们自定义的域名使用https访问我们的blog。<h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2>　　选择hexo做为blog的内容生成工具，是因为它有很多<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题模板</a>供我们使用。我在尝试了几个主题后，考虑到github提供的服务在国内访问速度的问题，最后还是使用的一个大家用的比较多的next模板，主题的替换很简单，在项目的根目录下使用命令:<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>,将主题模板取回来放置在themes文件夹下，如果要启用该模板，修改项目文件夹下_config.yml文件<strong>theme</strong>字段，值设置为：next。剩下的就是修改next文件下的配置文件，启用该主题的各种样式效果。<h2 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h2>　　为后续代码管理以及编写文档的保存，需要把项目上传到github管理，这里存在一个发布后的文件和源文件。根据我们在<a href="#搭建过程">搭建过程</a>中对_config.yml的设置，我们把发布后的文件保存在项目的master分支，则针对源文件就上传到该项目下一个分支来保存。在项目根目录下使用命令<code>git init</code>将该项目转换为git管理项目，添加远程仓库地址<code>git remote add origin git@github.com:jeremymj/jeremymj.github.io.git</code>，创建<code>.gitignore</code>文件，选择哪些文件不需要上传到github来管理。接着我们开始创建分支gh_dev，使用命令<code>git branch gh_dev</code>,使用命令<code>git push origin gh_dev</code>则可以把源文件提交到远程分支来管理。<strong>以后的操作都在本地分支gh_dev来完成,在编辑完成后通过hexo deploy发布到远端mater即可</strong><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2>　　这里列一些在搭建的过程中遇到的问题:<h3 id="cb-never-called"><a href="#cb-never-called" class="headerlink" title="cb() never called"></a>cb() never called</h3>　　在使用npm 方式来安装hexo 可执行程序时，遇到速度很慢的问题，但是在我的环境里面启用了自动代理，照理说应该会走代理的，就使用命令<code>npm config set proxy=http://127.0.0.1:1080</code>配置代理，后面拉取代码的速度果然有明显的提升，但是在拉取代码的过程中，出现错误提示，<code>cb() never called</code>。最后进入项目目录尝试使用<code>npm install</code> 获取刚才没有拉下来的代码，也是出现错误提示，在一篇帖子的提醒下，想起在配置代理的时候，当时查看的那个网页上给出的教程是 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> proxy=http://127.0.0.1:8087</span><br><span class="line">npm config <span class="built_in">set</span> registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure>
但是我想到只需要proxy,就没有配置registry,在添加好registry后，再次使用<code>npm install</code>，<strong>cb() never called！</strong>没有再次出现了，对于出现这个问题的原因，猜测是在默认情况下，npm在执行过程中会有默认registry。我在添加代理的过程中只指定了proxy,系统不再使用默认的registry，对于这个猜测，感觉也不合理，没有道理在用户没有指定registry时，不使用默认registry！由于现在没有对应环境来验证，先在这里记录一下。<h3 id="自定义域名失效"><a href="#自定义域名失效" class="headerlink" title="自定义域名失效"></a>自定义域名失效</h3>　　在测试的过程中，发现在使用<code>hexo deploy</code>后，有时会存在自定义域名不生效，需要在Settings界面重新设置。最后在源文件目录(本地gh_dev分支)中增加一个CNAME配置文件，在配置文件中填写<code>www.jspace.top</code>即可以解决这个问题<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>　　以上就是使用hexo搭建blog的过程，关于使用next主题配置的操作，也不再详细说，里面的配置项很多，针对配置项不能够满足我们对效果期望的地方，可以直接修改对应的css文件。关于样式的美化，需要花费的时间比较多，后续再慢慢的优化，至少目前是有一个地方，可以记录自己的学习笔记。</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
