{"meta":{"title":"Ming's Blog","subtitle":"always coding","description":"","author":"Ming","url":"https://www.jspace.top","root":"/"},"pages":[{"title":"","date":"2020-02-12T11:50:15.398Z","updated":"2020-02-12T11:50:15.398Z","comments":true,"path":"404.html","permalink":"https://www.jspace.top/404.html","excerpt":"","text":"+layout: false +--- 404"},{"title":"about","date":"2020-02-12T14:39:50.000Z","updated":"2020-02-12T06:41:39.810Z","comments":true,"path":"about/index.html","permalink":"https://www.jspace.top/about/index.html","excerpt":"","text":""},{"title":"About me","date":"2020-02-10T22:33:46.000Z","updated":"2020-02-11T12:34:47.475Z","comments":true,"path":"about/me.html","permalink":"https://www.jspace.top/about/me.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-02-12T19:44:35.000Z","updated":"2020-02-12T11:45:21.779Z","comments":true,"path":"categories/index.html","permalink":"https://www.jspace.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-12T14:39:38.000Z","updated":"2020-02-12T11:47:00.575Z","comments":true,"path":"tags/index.html","permalink":"https://www.jspace.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ethereum钱包功能开发之环境搭建","slug":"ethereum钱包功能开发之环境搭建","date":"2020-03-01T19:15:59.000Z","updated":"2020-03-01T11:28:51.233Z","comments":true,"path":"archives/426a759f.html","link":"","permalink":"https://www.jspace.top/archives/426a759f.html","excerpt":"最近在进行ethereum钱包功能的开发，在这里将实现钱包功能过程中遇到的问题进行记录。","text":"最近在进行ethereum钱包功能的开发，在这里将实现钱包功能过程中遇到的问题进行记录。从当前的进度来看，打算分为几篇文章来记录开发过程中的经历，算是对自己工作过程中进行一个记录与总结。 常见工具介绍 在进行Ethereum平台相关内容开发时可能会看到Geth，Mist,Truffle,Ganache等，这里对他们的区别做一个简单区分： Geth:是Ethereum的一个客户端实现，用于节点搭建等，是使用golang来实现的； Parity Ethereum,号称最快、最安全、最稳定的一个Ethereum客户端实现，是使用Rust来开发的； Mist:是etherum官方出的一个区块链浏览器，能够让用于进行交易，合约调用等； Truffle：简单的理解它是一个以太坊合约开发工具，它可以在智能合约开发、测试、发布等过程更方便，关于Truffle更多详细资料，查看这里 Ganache：是一个为开发者提供的私有Ethereum 区块链客户端, 可以用于本地部署, 开发, 测试应用程序, 测试代码,更多介绍查看这里技术架构 为便于提供不同平台的支持，我们使用Rust来实现钱包底层的功能，借助Rust交叉编译的便捷性，能够很方便的编译出目标平台所需要的动态库。借助Flutter在界面上实现的跨平台技术，能够解决Andorid,IOS等平台的一致性问题。关于Rust、Flutter的介绍可以点击链接进行了解，关于搭建Rust、Flutter交叉编译环境过程,可以参考这篇文章。本文重点对支持ethereum开发所需的环境搭建进行叙述。环境搭建 由于前期有开发Substrate的经验，知道ethereum与substrate来源的关系，开发过程中需要搭建一个节点来接收JsonRpc的请求。所以在ethereum钱包开发中也需要节点来参与调试。按照这种思路，我首先想到的是在本地直接运行一个ethereum节点，接入测试链或者搭建一个私链。由于使用Rust的原因，节点的选择上就自然的想到了Parity Ethereum（由于某些原因现在已经转移到OpenEthereum DAO）。节点程序编译 从github上取回最新的代码，进入项目的根目录，直接使用rust的编译命令Cargo build --release进行编译，等待几分钟之后就可以编译完成，编译生成的可执行程序在./target/release/目录下。直接运行./parity默认会启动一个全节点，会进行区块数据同步等操作，针对我们仅仅是想测试来说，不需要接入主网参与数据同步。可执行程序介绍在运行./parity --help后，可以看到程序支持的一些可选参数： –jsonrpc-apis，可选的值有：all, safe, debug, web3, net, eth, pubsub, personal, signer, parity, parity_pubsub,parity_accounts, parity_set, traces, rpc, secretstore, shh, shh_pubsub.这些rpc接口不是在每个节点都对外开放的，节点的类型也很多，所以在开发的时候确保所选的节点有开放你所需要的rpc接口这点很重要，涉及到技术方案的选择以及实现难度、工作量等问题。 –chain=[CHAIN]，可选的值有poacore, tobalaba, expanse,musicoin, ellaism, mix, callisto, morden, ropsten, kovan, rinkeby,goerli, kotti, poasokol, testnet, or dev，根据需要启动的节点类型，指定对应的chain。 –bootnodes,这个值是需要接入的节点地址，每个节点启动的时候都会输出当前自身节点的地址，用于其他节点的直接连接，地址格式如下：enode://xxxx@ip:port 除了跟启动参数外，./parity还提供很多工具命令，比如节点自身也具有钱包管理的功能，能够生成账户地址:运行parity account new，输入密码之后就会生成一个账户地址，同时该账户的私钥信息保存在~/.local/share/io.parity.ethereum/keys/ethereum/路径下。若是在启动节点的时候需要启用挖矿功能，则直接添加 --author [地址]，比如：./parity --author 0037a6b811ffeb6e072da21179d11b1406371c63,地址是去掉0x前缀的节点启动 由于我仅仅是想测试依赖节点的Rpc服务来验证钱包拼接的数据结构是否满足接口要求，所以我使用的启动方式是使用parity --config dev启动ETH开发节点，同时该节点默认存在一个地址0x00a329c0648769a73afac7f9381e08fb43dbea72，对应的私钥为：0x4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7（这个私钥仅用于开发测试，正式使用时请保存好自己的私钥），该账户中存在一定数目的测试ETH token，可以用于后续的开发测试。常用Rpc 虽然有不同的类型的节点，但是他们都有eth开头的最基础Rpc接口，我们可以借助这些接口实现我们的交易数据提交等功能，以下列举出的常用接口使用方式： eth_getTransactionCount，熟悉区块链开发的都清楚每笔交易都需要一个nonce,用于避免交易的重放攻击，确保交易的执行顺序，在拼接交易之前需要获取交易发起方当前总共发起的交易数，比如curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionCount&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545 eth_sendRawTransaction，用于构造离线交易签名，这种方式在钱包开发里面使用的场景比较多，需要依赖特定的节点就可以将交易提交到链上进行验证，这里稍微麻烦的是Rpc请求参数的构造，这在后面的文章做详细的介绍。该API请求数据格式:curl --data &#39;{&quot;method&quot;:&quot;eth_sendRawTransaction&quot;,&quot;params&quot;:[&quot;0xf86d808253e8837a1200941c9baedc94600b2d1c8a6d2bad1744e6182f300e8609184e72a0008568656c6c6f29a0a65b500258e5cf458db262758786e5c327285c924df687b8e9ce28e2fccb9451a07359f8dba84300d950bb534ac71a8d0eccb2a7e01a8cb70041c886588424be1c&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545。 eth_getTransactionByHash，在eth_sendRawTransaction的Rpc请求中会返回当前交易的结果。假如交易参数验证通过，会返回当前交易的hash，通过该Rpc可以查看该交易的具体详情，该API数据请求格式如下：curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x1486d4ff14e7fc6f991c17633e2b7a65ae52fc7a1be33845773a561a6955929e&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545 eth_getBalance，针对交易来说，比较重要的一个功能是查询指定地址上的ETH token数量,该API数据请求格式如下:curl --data &#39;{&quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545 以上是在钱包开发中使用频率较高的一些RPC接口，关于parity Ethereum的介绍以及使用文档，可以查看这里了解更多。总结 以上就是使用Ethereum来实现钱包功能所需要了解的一些内容，关于用户账户、交易构成、合约调用等内容后续慢慢的更新。虽然前期有substrate开发的经验，但是在实现的过程中也遇到了一些问题，我想把遇到的问题记录下来，再把解决问题过程中查阅的内容消化后记录下来，算是自己的学习笔记，可以用于自己以后复习。","categories":[],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://www.jspace.top/tags/Ethereum/"},{"name":"JsonRpc","slug":"JsonRpc","permalink":"https://www.jspace.top/tags/JsonRpc/"}]},{"title":"编译出现clear_on_drop错误的解决过程","slug":"编译出现clear_on_drop错误的解决过程","date":"2020-02-18T21:57:18.000Z","updated":"2020-02-18T14:53:14.279Z","comments":true,"path":"archives/1c5692ea.html","link":"","permalink":"https://www.jspace.top/archives/1c5692ea.html","excerpt":"由于远程开发需要部署一台测试服务器，在服务器上运行substrate实例后，接着需要部署测试合约，供同事调试使用。","text":"由于远程开发需要部署一台测试服务器，在服务器上运行substrate实例后，接着需要部署测试合约，供同事调试使用。 问题描述 从github上取回节前提交的代码，开始使用cargo contract build编译。在编译的过程中出现问题依赖文件不存在的的错误，出于以前调试substrate合约的经验，估计是依赖源码升级造成的。习惯性的先升级合约编译工具cargo-contract,从0.1.1升级到0.3.0，升级后继续编译，继续提示依赖的源码在依赖库不存在，这下反应过来了，他们最近又是大升级，变化比较大。刚开始还想把依赖项改成最新版的，经过一番尝试后，发现短时间内改不好，只有放弃。最后才想到在依赖库中指定提交的版本（增加rev+提交版本号），同时把使用的cargo-contract编译工具也还原到0.1.1版本，接着再编译修改后的合约项目，出现如下错误提示： 123456789101112131415161718192021222324252627282930313233error: failed to run custom build command for `clear_on_drop v0.2.3`Caused by: process didn't exit successfully: `/home/ming/work/temp/diamond/target/release/build/clear_on_drop-b2b3a807da34adf1/build-script-build` (exit code: 1)--- stdoutTARGET = Some(\"wasm32-unknown-unknown\")OPT_LEVEL = Some(\"z\")HOST = Some(\"x86_64-unknown-linux-gnu\")CC_wasm32-unknown-unknown = NoneCC_wasm32_unknown_unknown = NoneTARGET_CC = NoneCC = NoneCFLAGS_wasm32-unknown-unknown = NoneCFLAGS_wasm32_unknown_unknown = NoneTARGET_CFLAGS = NoneCFLAGS = NoneCRATE_CC_NO_DEFAULTS = NoneDEBUG = Some(\"false\")running: \"clang\" \"-Oz\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=wasm32-unknown-unknown\" \"-Wall\" \"-Wextra\" \"-o\" \"/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o\" \"-c\" \"src/hide.c\"cargo:warning=error: unable to create target: 'No available targets are compatible with this triple.'cargo:warning=1 error generated.exit code: 1--- stderrerror occurred: Command \"clang\" \"-Oz\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=wasm32-unknown-unknown\" \"-Wall\" \"-Wextra\" \"-o\" \"/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o\" \"-c\" \"src/hide.c\" with args \"clang\" did not execute successfully (status code exit code: 1).warning: build failed, waiting for other jobs to finish...error: build failederror: Build failed 看到这个错误，印象中是跟依赖库中sp-core、sp-io 是否使用 std features 相关，于是把这两个依赖项中的features取消掉，去掉后编译，出现错误： 12345678910111213141516171819202122232425262728293031323334353637error[E0152]: found duplicate lang item `panic_impl` --&gt; /home/ming/.cargo/git/checkouts/substrate-7e08433d4c370a21/b443dda/primitives/io/src/lib.rs:864:1 |864 | / pub fn panic(info: &amp;core::panic::PanicInfo) -&gt; ! &#123;865 | | unsafe &#123;866 | | let message = sp_std::alloc::format!(\"&#123;&#125;\", info);867 | | logging::log(LogLevel::Error, \"runtime\", message.as_bytes());868 | | core::intrinsics::abort()869 | | &#125;870 | | &#125; | |_^ | = note: the lang item is first defined in crate `std` (which `parity_scale_codec` depends on)error[E0152]: found duplicate lang item `oom` --&gt; /home/ming/.cargo/git/checkouts/substrate-7e08433d4c370a21/b443dda/primitives/io/src/lib.rs:875:1 |875 | / pub fn oom(_: core::alloc::Layout) -&gt; ! &#123;876 | | unsafe &#123;877 | | logging::log(LogLevel::Error, \"runtime\", b\"Runtime memory exhausted. Aborting\");878 | | core::intrinsics::abort();879 | | &#125;880 | | &#125; | |_^ | = note: the lang item is first defined in crate `std` (which `parity_scale_codec` depends on)error: aborting due to 2 previous errorsFor more information about this error, try `rustc --explain E0152`.error: could not compile `sp-io`.Caused by: process didn't exit successfully: `rustc --crate-name sp_io --edition=2018 /home/ming/.cargo/git/checkouts/substrate-7e08433d4c370a21/b443dda/primitives/io/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --emit=dep-info,metadata,link -C opt-level=z -C panic=abort -C overflow-checks=on -C metadata=1603ab4b0f5657bd -C extra-filename=-1603ab4b0f5657bd --out-dir /home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps --target wasm32-unknown-unknown -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/release/deps --extern hash_db=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libhash_db-2a1247b66dab3f2e.rmeta --extern codec=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libparity_scale_codec-97d1d02b4b85917a.rmeta --extern sp_core=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_core-ab9564e391d6b38c.rmeta --extern sp_runtime_interface=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_runtime_interface-2c02a210bd05a2c8.rmeta --extern sp_std=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_std-e4cf72917021ed6f.rmeta --cap-lints allow -C 'link-args=-z stack-size=65536 --import-memory'` (exit code: 1)warning: build failed, waiting for other jobs to finish...error: build failederror: Build failed 看到这个错误，知道不是依赖项features的原因，毕竟以前是调试通过的，接着又到github上查看clear_on_drop项目相关issue,发现有人问了类似的问题，从回复 1According to the error message, the issue is that your C compiler (in this case, clang) does not know the wasm32-unknown-unknown target. That is not something which could be fixed by this crate. 里面提到可能是clang的原因，一直到这里我都还没有反应过来问题出在哪里。在继续折腾一番后，鉴于到了该洗漱睡觉的时间了，就想到明天再弄吧。在洗漱的过程中想起以前在公司调试的时候也是出现过类似的问题，也花了很长时间都没有排查出来原因，因为在同事的电脑上能够正常编译，所以排除了代码出错，猜测大概率是编译环境的原因，同事使用的是ubuntu 19.10,我使用的是18.04，最后是直接重新安装系统解决这个编译问题（之前就对当前的系统不满意，算是一次性全部把这些问题解决吧）。接着查看家里电脑的系统版本号，居然还是ubuntu 18.04(印象中重装过一次系统)，看到这个版本号后，心里面顿时轻松了些，知道这个问题可以怎么解决了。给我的选择是重装系统（肯定会解决问题）还是尝试先升级llvm、clang版本(不一定能够解决这个问题)。最后还是想尝试升级clang版本号，毕竟家里面的电脑各种开发环境、工具折腾起来需要费不少精力。 升级clang 在网上查看一下llvm相关介绍后，了解这个属于编译系统比较底层的工具库，里面包含很多系统编译需要的工具，使用命令clang --version查看了当前的clang版本为6.0，跟github上llvm 的10.0 bate版本差距已经比较大了。编译llvm的过程并不顺利，在生成Makefile过程中没有添加参数，造成后续编译过程很慢，耗时很长，最后也没有编译完全（没有耐心等下去了）。在短暂的放弃后，最后按照帮助文档设置编译条件cmake -DLLVM_ENABLE_PROJECTS=clang -G &quot;Unix Makefiles&quot; ../llvm，在Makefile生成完后使用make -j8很快的就编译结束，最后使用sudo make install,使用clang --version 查看了最新版本为11.0.0,完成了clang升级。 验证 在clang 升级后，使用cargo clean将合约项目所有的以前编译的结果全部清除掉，使用cargo contract build重新编译合约，在经过几分钟的紧张时间后，看到wasm文件正确的编译出来了，心里面顿时轻松了，最后使用cargo contract generate-metadata编译合约ABI文件(metadata.json)，算是把折腾一天的问题给解决了。同时算是把系统编译环境做了一次更新，以后在编译中不会出现类似错误。 总结 在以后的开发中，若存在需要直接引用github上的项目源码，需要加上版本号，使用branch、tag、rev等字段； 在安装三方库的时候，查看官方文档时要仔细，把里面提到的注意事项读完。","categories":[],"tags":[{"name":"substrate","slug":"substrate","permalink":"https://www.jspace.top/tags/substrate/"},{"name":"智能合约","slug":"智能合约","permalink":"https://www.jspace.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}]},{"title":"使用github搭建自己的blog","slug":"使用github搭建自己的blog","date":"2020-02-16T11:19:02.000Z","updated":"2020-02-16T08:25:39.615Z","comments":true,"path":"archives/b7d807be.html","link":"","permalink":"https://www.jspace.top/archives/b7d807be.html","excerpt":"关于搭建blog的想法已经有很长时间了，虽然现在已经有成熟的框架能够快速搭建自己的blog服务，但是由于自己执行力的原因，一直没有实施。","text":"关于搭建blog的想法已经有很长时间了，虽然现在已经有成熟的框架能够快速搭建自己的blog服务，但是由于自己执行力的原因，一直没有实施。由于这次疫情原因在家休假时间比较长，终于完成了这一项任务。现将自己的操作过程记录一下。 技术选型 针对类似blog这种服务，现在有很多现成的免费服务可用，比如传统的博客园、CSDN提供的博客服务，以及最近几年出现的简书、知乎专栏、掘金等应用，都能满足大多数人记录文字的需求。或许是出于性格原因，我更想拥有一个自己的域名，自己完全能够控制的站点，所以排除了在以上提到的服务中选择的可能性。 刚开始考虑过购买VPS服务来实现，但是想到我现阶段的使用目的只是单纯记录我在后续工作、生活中的一些事情，也不追求访问速度，Github Pages服务可以满足我的需求（其中一个主要原因是Github Pages可以免费提供静态站点服务）。在确定好服务端之后，接着就是考虑内容生成工具，在网上查了一圈之后,从所需要准备的环境，以及内容编写工具以及维护程度等方面来考虑，最后还是选择Hexo。 搭建过程 由于自己的电脑上已经有nodejs、git等hexo所需要的工具，所以在搭建的过程中很快速，步骤也很简单（但是自己还是折腾了好长时间，后面再述），首先使用命令npm install -g hexo-cli安装好hexo基础环境，可执行程序。关于hexo教程可以到这里学习。在基础环境齐全之后，操作如下命令： hexo init &quot;project name&quot;，创建一个Hexo项目，后续的操作都在这个项目文件夹里面进行； hexo new [layout] &quot;title&quot;，创建一个文档，后续编写blog内容都可以通过这个命令来创建对应的md文件;默认情况下，创建的文档位于source/_posts/路径下； hexo generate 将该项目下的文档生成静态网页，生成内容位于public目录下； hexo server 启动一个本地服务，默认访问地址为http://localhost:4000/，可以通过该地址的内容进行预览；通过上面几步，一个blog的内容生成，预览基本上就完成了，但是我们还需要将生成的内容上传到github仓库中。通过Github Pages介绍我们知道，要想启用这个服务，我们需要在自己的github仓库中创建一个 “user”.github.io的项目，然后将public中的内容上传到该项目中即可。为方便上传内容到github，需要安装插件npm install hexo-deployer-git，同时在打开根目录中的_config.yml文件，在文档最后部分# Deployment增加如下配置，1234deploy: type: git repo: git@github.com:jeremymj/jeremymj.github.io.git branch: master 其中repo为将要上传的路径，为减少上传代码时需要输入github用户名、密码，我在这里使用了ssh方式上传，使用https方式也是可以的。在完成上述配置后，就可以使用命令hexo deploy将代码上传到github对应仓库中。自定义域名 在通过以上几个步骤的操作，正常情况下在浏览器中输入地址项目地址，比如我的:jeremymj.github.io,就可以打开blog的首页。但是假如我们不想使用这个项目地址访问blog，则我们可以为我们的blog绑定一个自己的域名。关于域名的购买，自己随便选择一个服务商就行。在域名中增加一条CNAME解析，eg：CNAME www.jspace.top jeremymj.github.io,不同的DNS服务商这里显示根式有所区别。正常情况下，一段时间后就可以通过配置的域名访问我们的blog了。支持https访问 现在github pages服务直接支持https服务，默认情况下使用xxx.github.io的方式访问，直接是https方式。针对自定义的域名路径，支持https也不再需要通过中间代理就可以直实现。操作方式也很方便，在我们创建的github.io项目仓库中找到Settings选项，找到GitHub Pages设置模块，在Custom domain中填上我们自定义的域名，选中Enforce HTTPS 选项即可。为了是刚才的配置生效，我们还需要到为我们的域名在家几条A类型记录，主机记录这个字段，在有些服务商的配置文件中是填写@,有些服务商直接不支持@类型的则这个字段不用填写，保持默认即可。对应的值为185.199.108.153、185.199.109.153、185.199.110.153、185.199.111.153中的任意一个，这里我增加了4条A类型记录。配置好后，正常情况下，一段时间后就可以通过我们自定义的域名使用https访问我们的blog。主题更换 选择hexo做为blog的内容生成工具，是因为它有很多主题模板供我们使用。我在尝试了几个主题后，考虑到github提供的服务在国内访问速度的问题，最后还是使用的一个大家用的比较多的next模板，主题的替换很简单，在项目的根目录下使用命令:git clone https://github.com/theme-next/hexo-theme-next themes/next,将主题模板取回来放置在themes文件夹下，如果要启用该模板，修改项目文件夹下_config.yml文件theme字段，值设置为：next。剩下的就是修改next文件下的配置文件，启用该主题的各种样式效果。代码管理 为后续代码管理以及编写文档的保存，需要把项目上传到github管理，这里存在一个发布后的文件和源文件。根据我们在搭建过程中对_config.yml的设置，我们把发布后的文件保存在项目的master分支，则针对源文件就上传到该项目下一个分支来保存。在项目根目录下使用命令git init将该项目转换为git管理项目，添加远程仓库地址git remote add origin git@github.com:jeremymj/jeremymj.github.io.git，创建.gitignore文件，选择哪些文件不需要上传到github来管理。接着我们开始创建分支gh_dev，使用命令git branch gh_dev,使用命令git push origin gh_dev则可以把源文件提交到远程分支来管理。以后的操作都在本地分支gh_dev来完成,在编辑完成后通过hexo deploy发布到远端mater即可遇到的问题 这里列一些在搭建的过程中遇到的问题:cb() never called 在使用npm 方式来安装hexo 可执行程序时，遇到速度很慢的问题，但是在我的环境里面启用了自动代理，照理说应该会走代理的，就使用命令npm config set proxy=http://127.0.0.1:1080配置代理，后面拉取代码的速度果然有明显的提升，但是在拉取代码的过程中，出现错误提示，cb() never called。最后进入项目目录尝试使用npm install 获取刚才没有拉下来的代码，也是出现错误提示，在一篇帖子的提醒下，想起在配置代理的时候，当时查看的那个网页上给出的教程是 12npm config set proxy=http://127.0.0.1:8087npm config set registry=http://registry.npmjs.org 但是我想到只需要proxy,就没有配置registry,在添加好registry后，再次使用npm install，cb() never called！没有再次出现了，对于出现这个问题的原因，猜测是在默认情况下，npm在执行过程中会有默认registry。我在添加代理的过程中只指定了proxy,系统不再使用默认的registry，对于这个猜测，感觉也不合理，没有道理在用户没有指定registry时，不使用默认registry！由于现在没有对应环境来验证，先在这里记录一下。自定义域名失效 在测试的过程中，发现在使用hexo deploy后，有时会存在自定义域名不生效，需要在Settings界面重新设置。最后在源文件目录(本地gh_dev分支)中增加一个CNAME配置文件，在配置文件中填写www.jspace.top即可以解决这个问题总结 以上就是使用hexo搭建blog的过程，关于使用next主题配置的操作，也不再详细说，里面的配置项很多，针对配置项不能够满足我们对效果期望的地方，可以直接修改对应的css文件。关于样式的美化，需要花费的时间比较多，后续再慢慢的优化，至少目前是有一个地方，可以记录自己的学习笔记。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.jspace.top/tags/hexo/"}]}]}