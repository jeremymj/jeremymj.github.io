{"meta":{"title":"Ming's Blog","subtitle":"always coding","description":"","author":"Ming","url":"https://www.jspace.top","root":"/"},"pages":[{"title":"","date":"2020-02-12T11:50:15.398Z","updated":"2020-02-12T11:50:15.398Z","comments":true,"path":"404.html","permalink":"https://www.jspace.top/404.html","excerpt":"","text":"+layout: false +--- 404"},{"title":"about","date":"2020-02-12T14:39:50.000Z","updated":"2020-02-12T06:41:39.810Z","comments":true,"path":"about/index.html","permalink":"https://www.jspace.top/about/index.html","excerpt":"","text":""},{"title":"About me","date":"2020-02-10T22:33:46.000Z","updated":"2020-02-11T12:34:47.475Z","comments":true,"path":"about/me.html","permalink":"https://www.jspace.top/about/me.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-02-12T19:44:35.000Z","updated":"2020-02-12T11:45:21.779Z","comments":true,"path":"categories/index.html","permalink":"https://www.jspace.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-12T14:39:38.000Z","updated":"2020-02-12T11:47:00.575Z","comments":true,"path":"tags/index.html","permalink":"https://www.jspace.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Result、Option组合子的使用","slug":"Result、Option组合子的使用","date":"2020-06-19T19:11:19.000Z","updated":"2020-06-19T11:23:32.318Z","comments":true,"path":"archives/d6945062.html","link":"","permalink":"https://www.jspace.top/archives/d6945062.html","excerpt":"在最近的code review过程中，发现自己针对RustResult&lt;T,E&gt;处理过程中使用的map,and_then,map_err这些组合子理解不是很到位，","text":"在最近的code review过程中，发现自己针对RustResult&lt;T,E&gt;处理过程中使用的map,and_then,map_err这些组合子理解不是很到位，今天经过查看API文档和运行demo程序，再次对这方面的知识进行学习。 在Rust程序的编写过程中，会存在大量返回Option、Result这类的结果，若是使用match方式来处理会发现处理过程比较繁琐，需要针对不同的情况分别做处理，特别是在经过多层嵌套后会造成代码的可读性降低。为了简化这方面的问题我们可以使用map,and_then等这些组合子来使得我们的程序更具有可读性。关于错误处理的更多内容，可以参考文章。下面分别针对map,and_then,map_err来进行介绍 使用方式介绍 通过在Rust API文档中搜索map这个关键词，我们会发现在很多地方都存在这个方法。这里我们查看Enum std::result::Result这个枚举里面的定义。通过文档我们知道map,and_then,map_err这类方法可以不用先将Result类型的值取出来，可以直接调用。 12pub fn map&lt;U, F&gt;(self, op: F) -&gt; Result&lt;U, E&gt; where F: FnOnce(T) -&gt; U, 根据map函数的签名，当Result&lt;T,E&gt;类型实例返回Ok结果时，使用map经过F作用后仅返回U类型，即将类型T转换为类型U。这里没有对U类型做任何说明，则表示U可以是任意类型，可以是普通类型，也可以是Result、Option这类更复杂的类型。假如在执行F这个闭包处理过程中出现Result类型结果，此时的U即为 Result类型，若是不继续处理这个结果， 最后的返回值为Result&lt;Result&lt;_,E&gt;&gt;; 123pub fn and_then&lt;U, F&gt;(self, op: F) -&gt; Result&lt;U, E&gt;where F: FnOnce(T) -&gt; Result&lt;U, E&gt;, 根据and_then函数的签名，知道使用and_then经过F作用后得到的结果为Result&lt;U, E&gt;，因此可以用来处理map 得到Result&lt;Result&lt;_,E&gt;&gt; 这种类型的结果(实现少一层result的效果)，也可以直接来处理针对F要返回Result的情况。通过上述定义我们知道，当在表达式中连续使用map调用不会改变最初函数调用可能返回的Err类型，但是在使用and_then时会返回E，此时就会存在当经过多次and_then调用后，返回的Error类型不一样，造成代码编译不能通过。因此在and_then的使用过程中需要将每次调用可能产生的的Err类型转换为一致的Err类型；关于如何返回一致的错误类型，可以查看rust关于自定义错误类型的相关内容（后续补充这部分的文档）。 123pub fn map_err&lt;F, O&gt;(self, op: O) -&gt; Result&lt;T, F&gt;where O: FnOnce(E) -&gt; F, 通过Api文档我们知道map_err只是用来处理Err这种情况的。其中需要注意的是当map,and_then这些组合子在一个表达式中多次连续使用时，产生的Err可能存在多个来源，但是我们在使用map_err时只会调用一次，并且map_err会匹配到对应的错误分支。为了更好的理解这部分的错误处理，可以参考以下代码示例。 代码片段123456789101112131415161718192021222324fn chain_match(num: &amp;str) -&gt; Result&lt;u32, String&gt; &#123; num.parse::&lt;u32&gt;() .and_then(|first| &#123; let test_num1_str = format!(\"&#123;&#125;\", first * 2); println!(\"test_num1_str is:&#123;&#125;\", test_num1_str); test_num1_str.parse::&lt;u32&gt;() &#125;) .and_then(|data| &#123; let test_num2_str = format!(\"&#123;&#125;\", data * 3); println!(\"test_num2_str is:&#123;&#125;\", test_num2_str); test_num2_str.parse::&lt;u32&gt;() &#125;) .map_err(|err| &#123; println!(\"encounter a error,detail is:&#123;&#125; \", err.to_string()); err.to_string() &#125;)&#125;#[test]fn chain_match_test() &#123; assert_eq!(Ok(60), chain_match(\"10\")); println!(\"---------------\"); assert_eq!(Ok(60), chain_match(\"a\"));&#125; 运行上述代码 我们得到以下结果 12345678test_num1_str is:20test_num2_str is:60---------------encounter a error,detail is:invalid digit found in string Expected :Err(\"invalid digit found in string\")Actual :Ok(60) 通过上述结果我们可以发现map_err处理的是第一次类型转换中产生的错误。针对后续两个and_then错误的处理，可以分别将test_num1_str、test_num1_str修改为类型转换会失败的情况，通过观察结果就可以发现map_err的处理细节。 总结 在上述的内容介绍中主要是围绕Result来进行的，针对Option他们的处理过程是类似的就没有分别进行叙述。针对Result、Option中还有很多类似的组合子，他们实现的效果是类似的，通过查看API文档能够了解他们适用的场景。通过这篇文章的总结，算是对组合子的使用有了更深的理解，能够方便自己以后在复习这方面知识时知道自己的推导过程。","categories":[],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://www.jspace.top/tags/Rust/"},{"name":"错误处理","slug":"错误处理","permalink":"https://www.jspace.top/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"}]},{"title":"ethereum合约调用","slug":"ethereum合约调用","date":"2020-05-31T22:46:55.000Z","updated":"2020-05-31T15:00:09.960Z","comments":true,"path":"archives/5618e610.html","link":"","permalink":"https://www.jspace.top/archives/5618e610.html","excerpt":"在ethereum交易签名中总结了以太坊交易的构成方式，不论是合约调用还是普通的ETH转账交易，交易的构造方式都是一样的。","text":"在ethereum交易签名中总结了以太坊交易的构成方式，不论是合约调用还是普通的ETH转账交易，交易的构造方式都是一样的。在转ETH的交易的中，目标地址to是我们将要转入的账户地址，针对合约调用，目标地址to是我们将要调用合约的地址。要构造出这两种交易，关键是交易中data字段的构造； ETH转账交易data构造根据以太坊开发文档，我们可以在ETH转账的时候填写一定长度的附加信息做为本次交易的备注信息。在钱包转账交易中，只需要将用户填写的备注信息转换为Vec&lt;u8&gt;格式并将结果赋值给data字段即可；当交易成功后，可以在etherscan中查询到当次交易添加的备注信息。 合约调用data字段构造当交易为合约调用时，data字段的内容将来至于两部分，其中是一部分数据来自于合约调用方法编码，另外一部分数据来至于交易的备注信息。通过这种方式实现了用户在合约调用时，添加备注信息的需求。他们的构造关系如下所示： 1234567//合约方法、参数编码let mut encode_data = ethtx::get_erc20_transfer_data(to_account, amount)?; //添加合约交易备注信息if let Some(addition_str) = user_input&#123; let mut addition =addition_str.as_bytes().to_vec(); encode_data.append(&amp;mut addition);&#125; 上述代码表示用户在调用erc20合约转账方法时参数拼接方式。其中get_erc20_transfer_data主要功能是通过调用如下代码实现： 123456fn encode_contract_input&lt;P&gt;(&amp;self, method: &amp;str, params: P) -&gt; Result&lt;Vec&lt;u8&gt;, error::Error&gt; where P: contract::tokens::Tokenize &#123; let data = self.abi.function(method).and_then(|function| &#123; function.encode_input(&amp;params.into_tokens()) &#125;)?; Ok(data) &#125; 下面内容重点描述encode_contract_input实现原理。 合约方法、参数编码当需要进行合约调用时，我们需要获取目标合约对应的ABI文件，ABI文件中有关于合约方法、所需参数以及参数类型的描述，通过一系列编码规则，最终会得到我们所需要的目标数据。整个编码数据是将方法编码和参数编码两部分参数组合起来的字节数组。使用下面的合约来详细说明编码的过程： 1234567pragma solidity ^0.4.16;contract Foo &#123; function bar(bytes3[2]) public pure &#123;&#125; function baz(uint32 x, bool y) public pure returns (bool r) &#123; r &#x3D; x &gt; 32 || y; &#125; function sam(bytes, bool, uint[]) public pure &#123;&#125;&#125; 方法编码获取将要调用方法对应的签名，以方法baz为例，它对应的函数签名为baz(uint32,bool)，对函数使用Keccak算法做Hash运算，取运算结果的前4个字节作为标识符来代表将要调用的方法。关键代码如下所示： 1234567fn fill_signature(name: &amp;str, params: &amp;[ParamType], result: &amp;mut [u8]) &#123; let types = params.iter().map(Writer::write).collect::&lt;Vec&lt;String&gt;&gt;().join(\",\"); let data: Vec&lt;u8&gt; = From::from(format!(\"&#123;&#125;(&#123;&#125;)\", name, types).as_str()); let mut sponge = Keccak::new_keccak256(); sponge.update(&amp;data); sponge.finalize(result);&#125; 针对baz(uint32,bool)的计算结果为0xcdcd77c0。（这里取前4个字节的原因估计在定义的合约方法中有足够大的概率避免hash冲突又能节省空间）。 数据编码与方法编码相比较，数据编码就显得复杂的多。在合约参数定义中，存在静态类型数据和动态类型，这里将uint&lt;M&gt;、int&lt;M&gt;,bool，address定义为静态类型，其中0 &lt; M &lt;= 256&amp;&amp;M % 8 == 0代表暂用的字节数；动态数据类型定义比如：bytes、string、T[]、T[k]、(T1,…,Tk)，其中T为任意类型；针对静态类型除address占用20字节外，另外的静态类型都用32字节表示，通过在左边补零的方式补齐。以调用baz方法，传入参数69，true为例； 69 编码为十六进制为0x45,通过移位补齐32字节的方式，最后编码的结果为：0x0000000000000000000000000000000000000000000000000000000000000045； true,最后编码的结果的为0x0000000000000000000000000000000000000000000000000000000000000001；所以针对baz(69,true)最后编码出来的结果的为：0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001； 针对同时包含动态类型和静态类型的方法，遵循静态数据直接编码存放，动态类型数据存放位置索引，通过索引来指示实际的编码数据。以编码sam方法为例: sam(&quot;dave&quot;, true 、[1,2,3]),该方法中包含两个动态类型，针对第一个参数，先传入真实数据的索引位置，是从第96(后面有详细的计算说明为什么是这个数)个字节位置开始，计算规则如下： 第一个参数索引位置表示 占32字节； 第二个参数为静态类型，直接表示为0x0000000000000000000000000000000000000000000000000000000000000001，占用32个字节； 第三个参数，为动态类型，直接使用32个字节表示索引。 因此第一个参数的真实数据是从(32+32+32 = 96)位置开始的。将所有的参数都表示完后，后面就开始添加动态类型数据。因为动态类型数据长度是动态变化的，所以真实数据开始前还需要有长度声明的字段，这个字段也是32字节的大小； “dave”的长度为4，编码后的数据为0x0000000000000000000000000000000000000000000000000000000000000004； 针对dave直接转换为十六进制为0x64617665，不满足32字节的大小，在后续通过补零的方式补齐，最后的编码的结果为0x6461766500000000000000000000000000000000000000000000000000000000; 通过上面的描述，能够计算出来第三个参数的其实位置索引为：(96+64=160),即编码后的数据为0x00000000000000000000000000000000000000000000000000000000000000a0, [1,2,3]是动态类型数据，先编码数组的长度为0x0000000000000000000000000000000000000000000000000000000000000003； 数组中对应的成员对应的编码分别为 0x0000000000000000000000000000000000000000000000000000000000000001; 0x0000000000000000000000000000000000000000000000000000000000000002; 0x0000000000000000000000000000000000000000000000000000000000000003; 综合上面的编码数据，sam(&quot;dave&quot;, true 、[1,2,3])最后编码的结果为0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003 通过上面合约方法、参数编码的介绍，将编码后的结果与用户的备注信息拼接，就完成了构造交易结构中data字段的构造。在上述编码的过程中，我们可以发现它的编码规则，当编码的数据为字符串类型时，数据直接通过右补零的方式补齐32字节的大小，当数据为数值型时，是通过在左边添加零偏移的方式补齐32字节大小空间。关于合约编码更详细的内容可以参考文档. 总结在最近开发钱包过程中，这部分的功能已经编码结束已经有一段时间了，当时为了实现在转ERC20时同时实现交易备注信息的添加，在网上查了相关资料都没有看到文档说明怎么来处理合约调用编码数据与用户备注信息的关系，今天算是对这部分知识的复习。","categories":[],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://www.jspace.top/tags/Ethereum/"},{"name":"合约数据编码","slug":"合约数据编码","permalink":"https://www.jspace.top/tags/%E5%90%88%E7%BA%A6%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"}]},{"title":"ethereum交易签名","slug":"ethereum交易签名","date":"2020-05-10T12:21:57.000Z","updated":"2020-05-10T04:37:45.102Z","comments":true,"path":"archives/ed176158.html","link":"","permalink":"https://www.jspace.top/archives/ed176158.html","excerpt":"今天把前段在实现ETH交易过程中遇到的问题做一下记录，算是对这部分知识的复习。要想在以太坊中完成一笔交易，可以借助节点对外开放的eth_sendTransaction或eth_sendRawTransaction这两个JsonRpc接口。","text":"今天把前段在实现ETH交易过程中遇到的问题做一下记录，算是对这部分知识的复习。要想在以太坊中完成一笔交易，可以借助节点对外开放的eth_sendTransaction或eth_sendRawTransaction这两个JsonRpc接口。我们只需要拼接好这个接口需要的参数再通过网络提交到节点即可。本文的重点是叙述怎么来拼接这个目标参数，由于在钱包开发中主要使用eth_sendRawTransaction这个接口，下面就对这接口所需要的参数进行阐述。 交易构造 通过查阅Ethereum的文档，知道构造原始交易所需要的结构如下所示： 1234567891011121314151617/// Description of a Transaction, pending or in the chain.#[derive(Debug, Default, Clone, PartialEq, Deserialize, Serialize)]pub struct RawTransaction &#123; /// Nonce pub nonce: U256, /// Recipient (None when contract creation) pub to: Option&lt;H160&gt;, /// Transfered value pub value: U256, /// Gas Price #[serde(rename = \"gasPrice\")] pub gas_price: U256, /// Gas amount pub gas: U256, /// Input data pub data: Vec&lt;u8&gt;,&#125; 注意：自己在实现过程中定义原始交易参数结构体时，必须要确保参数顺序相同。在构造交易时会将该结构体使用RLP方式编码，当节点收到原始交易时会按照这个结构对收到的数据做编码还原；从RawTransaction我们知道在一笔交易中涉及到nonce,to，value,gas_price,gas,data这五个属性。这下面是对这些属性的说明： nonce 在区块链交易中都需要有nonce这个参数，用于表示当前发送地址的第几笔交易，能够确保交易的顺序，防止节点被交易重放攻击。注意： 初始交易是从编号0开始的，可以通过调用eth_getTransactionCount获取当前交易的值； 节点在验证交易时会校验当前的nonce是否为正确的值，若交易中的nonce值比真实值小，则这笔交易会直接返回nonce错误； 若交易中的nonce值比真实值大，则会将该交易放入一个future队列里面，等待中间缺失的交易进来后再继续验证这笔交易；地址(to) to表示交易的接受地址，这个地址通常可以是一个外部地址（该地址对应的私钥有实际的控制者），表示一笔转账操作；也可以是一个内部地址(合约地址)，表示合约调用。value 这个值表示该交易需要转给目标地址的ETH数量，需要注意填写的数值是最小单位（wei）,通常在钱包界面上填写的数值单位是ether，在处理的时候需要做单位转换；这里有几种情况需要注意： 填写正常的数值且to 地址是一个外部地址，表示将指定数量的token转到指定地址； 填写的数值为0，且to地址是一个外部地址，这种操作除了浪费gas之外，没有任何作用； 当to地址是一个合约地址时且value不为空，这样的交易也会将发送者地址上的eth代币转到合约地址上，由于合约地址是内部地址，没人知道对应的私钥，所以这些token会成为死币；gas_price 表示每个单位的gas值多少wei，我们知道Ethereum EVM在执行过程中每个操作都需要消耗gas,gas是一个不随ETH波动而波动的单位定义，用于表示调用者愿意为这笔交易每个步骤花费多少token，通常情况下调用者给出的gas_price价格越高，矿工会优先执行执行；为了防止恶意抬高gas_price，Ethereum针对gas_price有专门的算法来进行控制，开发者在构造交易的时候，直接调用节点提供的rpc接口eth_gasPrice即可；还需要注意的是，这里的数值也需要填写最小的单位wei。gas 表示愿意交易在执行过程中，愿意支付的最大gas数量，也就是我们常见的gas_limit数值；若是指定的gas数量太少，交易在执行的过程中gas消耗完后，就会返回错误；若是指定的gas数量比较大，调用者账户上也有足够的gas可扣，则交易会正常的执行，在执行完后会将多余的gas返回到调用者的账户上。data 在以太坊中针对每笔交易都可以填写附加信息，针对这个字段的内容我打算放到下一篇关于合约调用的文章中。以上部分就是构造一个以太坊交易所需要的基本数据，要是构造的交易能够在链上被虚拟机执行，还需要对交易进行签名操作；编码在以太坊中，数据的编码使用RLP的编码方式来进行的，关于编码实现的具体方式，可以查看wiki,只是需要注意在编码的过程中，需要注意字段的顺序 12345678910111213//对RawTransaction 数据使用RLP编码 fn encode(&amp;self, rlp: &amp;mut RlpStream) &#123; rlp.append(&amp;self.nonce); rlp.append(&amp;self.gas_price); rlp.append(&amp;self.gas); if let Some(ref t) = self.to &#123; rlp.append(t); &#125; else &#123; rlp.append(&amp;vec![]); &#125; rlp.append(&amp;self.value); rlp.append(&amp;self.data); &#125; 之所以按照fn encode方式将数据添加到RlpStream实例中，是因为节点验证交易时会进行如下方式的数据解码 123456789101112131415161718192021222324//还原出原RLP数据格式impl rlp::Decodable for UnverifiedTransaction &#123; fn decode(d: &amp;Rlp) -&gt; Result&lt;Self, DecoderError&gt; &#123; //rlp编码 针对数据长度 是有特征？？ if d.item_count()? != 9 &#123; return Err(DecoderError::RlpIncorrectListLen); &#125; let hash = keccak(d.as_raw()); Ok(UnverifiedTransaction &#123; unsigned: Transaction &#123; nonce: d.val_at(0)?, gas_price: d.val_at(1)?, gas: d.val_at(2)?, action: d.val_at(3)?, value: d.val_at(4)?, data: d.val_at(5)?, &#125;, v: d.val_at(6)?, r: d.val_at(7)?, s: d.val_at(8)?, hash, &#125;) &#125;&#125; 签名生成 以太坊使用Secp256k1算法来签名，我们知道签名都有计算源数据的hash值过程。针对交易hash值的计算过程如下： 123456789101112fn hash(&amp;self, chain_id: Option&lt;u64&gt;) -&gt; [u8; 32] &#123; let mut stream = RlpStream::new(); stream.begin_unbounded_list(); self.encode(&amp;mut stream); if let Some(n) = chain_id &#123; stream.append(&amp;n); stream.append(&amp;U256::zero()); stream.append(&amp;U256::zero()); &#125; stream.finalize_unbounded_list(); keccak(stream.out().as_slice()) &#125; 其中chain_id表示当前交易用于的目标链，以太坊使用这个参数的目的是防止在不同的链上提交相同的数据，让节点不能提前检查出风险交易，增加了链的稳定性。可以通过构造JsonRpc请求数据{&quot;method&quot;:&quot;eth_chainId&quot;,&quot;params&quot;:[],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}获取到；hash数据签名的过程如下： 123456789101112fn ecdsa_sign(hash: &amp;[u8], private_key: &amp;[u8], chain_id: u64) -&gt; EcdsaSig &#123; let s = Secp256k1::signing_only(); let msg = Message::from_slice(hash).unwrap(); let key = SecretKey::from_slice(private_key).unwrap(); let (v, sig_bytes) = s.sign_recoverable(&amp;msg, &amp;key).serialize_compact(); EcdsaSig &#123; v: v.to_i32() as u64 + chain_id * 2 + 35, r: sig_bytes[0..32].to_vec(), s: sig_bytes[32..64].to_vec(), &#125;&#125; 签名最后得到的v、r、s值和交易结构体编码的数据一起构成了eth_sendRawTransaction这个接口所需要的数据；下面是完整的交易签名实现： 1234567891011121314151617181920pub fn sign(&amp;self, private_key: &amp;[u8], chain_id: Option&lt;u64&gt;) -&gt; Vec&lt;u8&gt; &#123; let hash_data = self.hash(chain_id); let sig = ecdsa_sign(&amp;hash_data, private_key, chain_id.unwrap()); let mut r_n = sig.r; let mut s_n = sig.s; while r_n[0] == 0 &#123; r_n.remove(0); &#125; while s_n[0] == 0 &#123; s_n.remove(0); &#125; let mut tx = RlpStream::new(); tx.begin_unbounded_list(); self.encode(&amp;mut tx); tx.append(&amp;sig.v); tx.append(&amp;r_n); tx.append(&amp;s_n); tx.finalize_unbounded_list(); tx.out() &#125; 从上述代码可以看出，我们通常听到的交易签名，其实是包含了通过keccak256计算交易hash值、使用Sec256K1对Hash签名并将签名结果和交易详情编码在一起，最后输出Hex格式数据的过程。 总结 通过上面的描述详细说明了以太坊交易构成的过程，这也是当前钱包在构造用户交易的核心过程，该过程涉及到的内容很多，后续可以继续对里面的知识点进行阐述。","categories":[],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://www.jspace.top/tags/Ethereum/"},{"name":"交易签名","slug":"交易签名","permalink":"https://www.jspace.top/tags/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D/"},{"name":"数据编码","slug":"数据编码","permalink":"https://www.jspace.top/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"}]},{"title":"ethereum钱包功能开发之环境搭建","slug":"ethereum钱包功能开发之环境搭建","date":"2020-03-01T19:15:59.000Z","updated":"2020-03-01T11:28:51.233Z","comments":true,"path":"archives/426a759f.html","link":"","permalink":"https://www.jspace.top/archives/426a759f.html","excerpt":"最近在进行ethereum钱包功能的开发，在这里将实现钱包功能过程中遇到的问题进行记录。","text":"最近在进行ethereum钱包功能的开发，在这里将实现钱包功能过程中遇到的问题进行记录。从当前的进度来看，打算分为几篇文章来记录开发过程中的经历，算是对自己工作过程中进行一个记录与总结。 常见工具介绍 在进行Ethereum平台相关内容开发时可能会看到Geth，Mist,Truffle,Ganache等，这里对他们的区别做一个简单区分： Geth:是Ethereum的一个客户端实现，用于节点搭建等，是使用golang来实现的； Parity Ethereum,号称最快、最安全、最稳定的一个Ethereum客户端实现，是使用Rust来开发的； Mist:是etherum官方出的一个区块链浏览器，能够让用于进行交易，合约调用等； Truffle：简单的理解它是一个以太坊合约开发工具，它可以在智能合约开发、测试、发布等过程更方便，关于Truffle更多详细资料，查看这里 Ganache：是一个为开发者提供的私有Ethereum 区块链客户端, 可以用于本地部署, 开发, 测试应用程序, 测试代码,更多介绍查看这里技术架构 为便于提供不同平台的支持，我们使用Rust来实现钱包底层的功能，借助Rust交叉编译的便捷性，能够很方便的编译出目标平台所需要的动态库。借助Flutter在界面上实现的跨平台技术，能够解决Andorid,IOS等平台的一致性问题。关于Rust、Flutter的介绍可以点击链接进行了解，关于搭建Rust、Flutter交叉编译环境过程,可以参考这篇文章。本文重点对支持ethereum开发所需的环境搭建进行叙述。环境搭建 由于前期有开发Substrate的经验，知道ethereum与substrate来源的关系，开发过程中需要搭建一个节点来接收JsonRpc的请求。所以在ethereum钱包开发中也需要节点来参与调试。按照这种思路，我首先想到的是在本地直接运行一个ethereum节点，接入测试链或者搭建一个私链。由于使用Rust的原因，节点的选择上就自然的想到了Parity Ethereum（由于某些原因现在已经转移到OpenEthereum DAO）。节点程序编译 从github上取回最新的代码，进入项目的根目录，直接使用rust的编译命令Cargo build --release进行编译，等待几分钟之后就可以编译完成，编译生成的可执行程序在./target/release/目录下。直接运行./parity默认会启动一个全节点，会进行区块数据同步等操作，针对我们仅仅是想测试来说，不需要接入主网参与数据同步。可执行程序介绍在运行./parity --help后，可以看到程序支持的一些可选参数： –jsonrpc-apis，可选的值有：all, safe, debug, web3, net, eth, pubsub, personal, signer, parity, parity_pubsub,parity_accounts, parity_set, traces, rpc, secretstore, shh, shh_pubsub.这些rpc接口不是在每个节点都对外开放的，节点的类型也很多，所以在开发的时候确保所选的节点有开放你所需要的rpc接口这点很重要，涉及到技术方案的选择以及实现难度、工作量等问题。 –chain=[CHAIN]，可选的值有poacore, tobalaba, expanse,musicoin, ellaism, mix, callisto, morden, ropsten, kovan, rinkeby,goerli, kotti, poasokol, testnet, or dev，根据需要启动的节点类型，指定对应的chain。 –bootnodes,这个值是需要接入的节点地址，每个节点启动的时候都会输出当前自身节点的地址，用于其他节点的直接连接，地址格式如下：enode://xxxx@ip:port 除了跟启动参数外，./parity还提供很多工具命令，比如节点自身也具有钱包管理的功能，能够生成账户地址:运行parity account new，输入密码之后就会生成一个账户地址，同时该账户的私钥信息保存在~/.local/share/io.parity.ethereum/keys/ethereum/路径下。若是在启动节点的时候需要启用挖矿功能，则直接添加 --author [地址]，比如：./parity --author 0037a6b811ffeb6e072da21179d11b1406371c63,地址是去掉0x前缀的节点启动 由于我仅仅是想测试依赖节点的Rpc服务来验证钱包拼接的数据结构是否满足接口要求，所以我使用的启动方式是使用parity --config dev启动ETH开发节点，同时该节点默认存在一个地址0x00a329c0648769a73afac7f9381e08fb43dbea72，对应的私钥为：0x4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7（这个私钥仅用于开发测试，正式使用时请保存好自己的私钥），该账户中存在一定数目的测试ETH token，可以用于后续的开发测试。常用Rpc 虽然有不同的类型的节点，但是他们都有eth开头的最基础Rpc接口，我们可以借助这些接口实现我们的交易数据提交等功能，以下列举出的常用接口使用方式： eth_getTransactionCount，熟悉区块链开发的都清楚每笔交易都需要一个nonce,用于避免交易的重放攻击，确保交易的执行顺序，在拼接交易之前需要获取交易发起方当前总共发起的交易数，比如curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionCount&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545 eth_sendRawTransaction，用于构造离线交易签名，这种方式在钱包开发里面使用的场景比较多，需要依赖特定的节点就可以将交易提交到链上进行验证，这里稍微麻烦的是Rpc请求参数的构造，这在后面的文章做详细的介绍。该API请求数据格式:curl --data &#39;{&quot;method&quot;:&quot;eth_sendRawTransaction&quot;,&quot;params&quot;:[&quot;0xf86d808253e8837a1200941c9baedc94600b2d1c8a6d2bad1744e6182f300e8609184e72a0008568656c6c6f29a0a65b500258e5cf458db262758786e5c327285c924df687b8e9ce28e2fccb9451a07359f8dba84300d950bb534ac71a8d0eccb2a7e01a8cb70041c886588424be1c&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545。 eth_getTransactionByHash，在eth_sendRawTransaction的Rpc请求中会返回当前交易的结果。假如交易参数验证通过，会返回当前交易的hash，通过该Rpc可以查看该交易的具体详情，该API数据请求格式如下：curl --data &#39;{&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x1486d4ff14e7fc6f991c17633e2b7a65ae52fc7a1be33845773a561a6955929e&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545 eth_getBalance，针对交易来说，比较重要的一个功能是查询指定地址上的ETH token数量,该API数据请求格式如下:curl --data &#39;{&quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;],&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;}&#39; -H &quot;Content-Type: application/json&quot; -X POST localhost:8545 以上是在钱包开发中使用频率较高的一些RPC接口，关于parity Ethereum的介绍以及使用文档，可以查看这里了解更多。总结 以上就是使用Ethereum来实现钱包功能所需要了解的一些内容，关于用户账户、交易构成、合约调用等内容后续慢慢的更新。虽然前期有substrate开发的经验，但是在实现的过程中也遇到了一些问题，我想把遇到的问题记录下来，再把解决问题过程中查阅的内容消化后记录下来，算是自己的学习笔记，可以用于自己以后复习。","categories":[],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"https://www.jspace.top/tags/Ethereum/"},{"name":"JsonRpc","slug":"JsonRpc","permalink":"https://www.jspace.top/tags/JsonRpc/"}]},{"title":"编译出现clear_on_drop错误的解决过程","slug":"编译出现clear_on_drop错误的解决过程","date":"2020-02-18T21:57:18.000Z","updated":"2020-02-18T14:53:14.279Z","comments":true,"path":"archives/1c5692ea.html","link":"","permalink":"https://www.jspace.top/archives/1c5692ea.html","excerpt":"由于远程开发需要部署一台测试服务器，在服务器上运行substrate实例后，接着需要部署测试合约，供同事调试使用。","text":"由于远程开发需要部署一台测试服务器，在服务器上运行substrate实例后，接着需要部署测试合约，供同事调试使用。 问题描述 从github上取回节前提交的代码，开始使用cargo contract build编译。在编译的过程中出现问题依赖文件不存在的的错误，出于以前调试substrate合约的经验，估计是依赖源码升级造成的。习惯性的先升级合约编译工具cargo-contract,从0.1.1升级到0.3.0，升级后继续编译，继续提示依赖的源码在依赖库不存在，这下反应过来了，他们最近又是大升级，变化比较大。刚开始还想把依赖项改成最新版的，经过一番尝试后，发现短时间内改不好，只有放弃。最后才想到在依赖库中指定提交的版本（增加rev+提交版本号），同时把使用的cargo-contract编译工具也还原到0.1.1版本，接着再编译修改后的合约项目，出现如下错误提示： 123456789101112131415161718192021222324252627282930313233error: failed to run custom build command for `clear_on_drop v0.2.3`Caused by: process didn't exit successfully: `/home/ming/work/temp/diamond/target/release/build/clear_on_drop-b2b3a807da34adf1/build-script-build` (exit code: 1)--- stdoutTARGET = Some(\"wasm32-unknown-unknown\")OPT_LEVEL = Some(\"z\")HOST = Some(\"x86_64-unknown-linux-gnu\")CC_wasm32-unknown-unknown = NoneCC_wasm32_unknown_unknown = NoneTARGET_CC = NoneCC = NoneCFLAGS_wasm32-unknown-unknown = NoneCFLAGS_wasm32_unknown_unknown = NoneTARGET_CFLAGS = NoneCFLAGS = NoneCRATE_CC_NO_DEFAULTS = NoneDEBUG = Some(\"false\")running: \"clang\" \"-Oz\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=wasm32-unknown-unknown\" \"-Wall\" \"-Wextra\" \"-o\" \"/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o\" \"-c\" \"src/hide.c\"cargo:warning=error: unable to create target: 'No available targets are compatible with this triple.'cargo:warning=1 error generated.exit code: 1--- stderrerror occurred: Command \"clang\" \"-Oz\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=wasm32-unknown-unknown\" \"-Wall\" \"-Wextra\" \"-o\" \"/home/ming/work/temp/diamond/target/wasm32-unknown-unknown/release/build/clear_on_drop-c7f1c48f1d7a25a0/out/src/hide.o\" \"-c\" \"src/hide.c\" with args \"clang\" did not execute successfully (status code exit code: 1).warning: build failed, waiting for other jobs to finish...error: build failederror: Build failed 看到这个错误，印象中是跟依赖库中sp-core、sp-io 是否使用 std features 相关，于是把这两个依赖项中的features取消掉，去掉后编译，出现错误： 12345678910111213141516171819202122232425262728293031323334353637error[E0152]: found duplicate lang item `panic_impl` --&gt; /home/ming/.cargo/git/checkouts/substrate-7e08433d4c370a21/b443dda/primitives/io/src/lib.rs:864:1 |864 | / pub fn panic(info: &amp;core::panic::PanicInfo) -&gt; ! &#123;865 | | unsafe &#123;866 | | let message = sp_std::alloc::format!(\"&#123;&#125;\", info);867 | | logging::log(LogLevel::Error, \"runtime\", message.as_bytes());868 | | core::intrinsics::abort()869 | | &#125;870 | | &#125; | |_^ | = note: the lang item is first defined in crate `std` (which `parity_scale_codec` depends on)error[E0152]: found duplicate lang item `oom` --&gt; /home/ming/.cargo/git/checkouts/substrate-7e08433d4c370a21/b443dda/primitives/io/src/lib.rs:875:1 |875 | / pub fn oom(_: core::alloc::Layout) -&gt; ! &#123;876 | | unsafe &#123;877 | | logging::log(LogLevel::Error, \"runtime\", b\"Runtime memory exhausted. Aborting\");878 | | core::intrinsics::abort();879 | | &#125;880 | | &#125; | |_^ | = note: the lang item is first defined in crate `std` (which `parity_scale_codec` depends on)error: aborting due to 2 previous errorsFor more information about this error, try `rustc --explain E0152`.error: could not compile `sp-io`.Caused by: process didn't exit successfully: `rustc --crate-name sp_io --edition=2018 /home/ming/.cargo/git/checkouts/substrate-7e08433d4c370a21/b443dda/primitives/io/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --emit=dep-info,metadata,link -C opt-level=z -C panic=abort -C overflow-checks=on -C metadata=1603ab4b0f5657bd -C extra-filename=-1603ab4b0f5657bd --out-dir /home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps --target wasm32-unknown-unknown -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps -L dependency=/home/ming/work/temp/envtest/diamond/contract/diamond/target/release/deps --extern hash_db=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libhash_db-2a1247b66dab3f2e.rmeta --extern codec=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libparity_scale_codec-97d1d02b4b85917a.rmeta --extern sp_core=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_core-ab9564e391d6b38c.rmeta --extern sp_runtime_interface=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_runtime_interface-2c02a210bd05a2c8.rmeta --extern sp_std=/home/ming/work/temp/envtest/diamond/contract/diamond/target/wasm32-unknown-unknown/release/deps/libsp_std-e4cf72917021ed6f.rmeta --cap-lints allow -C 'link-args=-z stack-size=65536 --import-memory'` (exit code: 1)warning: build failed, waiting for other jobs to finish...error: build failederror: Build failed 看到这个错误，知道不是依赖项features的原因，毕竟以前是调试通过的，接着又到github上查看clear_on_drop项目相关issue,发现有人问了类似的问题，从回复 1According to the error message, the issue is that your C compiler (in this case, clang) does not know the wasm32-unknown-unknown target. That is not something which could be fixed by this crate. 里面提到可能是clang的原因，一直到这里我都还没有反应过来问题出在哪里。在继续折腾一番后，鉴于到了该洗漱睡觉的时间了，就想到明天再弄吧。在洗漱的过程中想起以前在公司调试的时候也是出现过类似的问题，也花了很长时间都没有排查出来原因，因为在同事的电脑上能够正常编译，所以排除了代码出错，猜测大概率是编译环境的原因，同事使用的是ubuntu 19.10,我使用的是18.04，最后是直接重新安装系统解决这个编译问题（之前就对当前的系统不满意，算是一次性全部把这些问题解决吧）。接着查看家里电脑的系统版本号，居然还是ubuntu 18.04(印象中重装过一次系统)，看到这个版本号后，心里面顿时轻松了些，知道这个问题可以怎么解决了。给我的选择是重装系统（肯定会解决问题）还是尝试先升级llvm、clang版本(不一定能够解决这个问题)。最后还是想尝试升级clang版本号，毕竟家里面的电脑各种开发环境、工具折腾起来需要费不少精力。 升级clang 在网上查看一下llvm相关介绍后，了解这个属于编译系统比较底层的工具库，里面包含很多系统编译需要的工具，使用命令clang --version查看了当前的clang版本为6.0，跟github上llvm 的10.0 bate版本差距已经比较大了。编译llvm的过程并不顺利，在生成Makefile过程中没有添加参数，造成后续编译过程很慢，耗时很长，最后也没有编译完全（没有耐心等下去了）。在短暂的放弃后，最后按照帮助文档设置编译条件cmake -DLLVM_ENABLE_PROJECTS=clang -G &quot;Unix Makefiles&quot; ../llvm，在Makefile生成完后使用make -j8很快的就编译结束，最后使用sudo make install,使用clang --version 查看了最新版本为11.0.0,完成了clang升级。 验证 在clang 升级后，使用cargo clean将合约项目所有的以前编译的结果全部清除掉，使用cargo contract build重新编译合约，在经过几分钟的紧张时间后，看到wasm文件正确的编译出来了，心里面顿时轻松了，最后使用cargo contract generate-metadata编译合约ABI文件(metadata.json)，算是把折腾一天的问题给解决了。同时算是把系统编译环境做了一次更新，以后在编译中不会出现类似错误。 总结 在以后的开发中，若存在需要直接引用github上的项目源码，需要加上版本号，使用branch、tag、rev等字段； 在安装三方库的时候，查看官方文档时要仔细，把里面提到的注意事项读完。","categories":[],"tags":[{"name":"substrate","slug":"substrate","permalink":"https://www.jspace.top/tags/substrate/"},{"name":"智能合约","slug":"智能合约","permalink":"https://www.jspace.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}]},{"title":"使用github搭建自己的blog","slug":"使用github搭建自己的blog","date":"2020-02-16T11:19:02.000Z","updated":"2020-02-16T08:25:39.615Z","comments":true,"path":"archives/b7d807be.html","link":"","permalink":"https://www.jspace.top/archives/b7d807be.html","excerpt":"关于搭建blog的想法已经有很长时间了，虽然现在已经有成熟的框架能够快速搭建自己的blog服务，但是由于自己执行力的原因，一直没有实施。","text":"关于搭建blog的想法已经有很长时间了，虽然现在已经有成熟的框架能够快速搭建自己的blog服务，但是由于自己执行力的原因，一直没有实施。由于这次疫情原因在家休假时间比较长，终于完成了这一项任务。现将自己的操作过程记录一下。 技术选型 针对类似blog这种服务，现在有很多现成的免费服务可用，比如传统的博客园、CSDN提供的博客服务，以及最近几年出现的简书、知乎专栏、掘金等应用，都能满足大多数人记录文字的需求。或许是出于性格原因，我更想拥有一个自己的域名，自己完全能够控制的站点，所以排除了在以上提到的服务中选择的可能性。 刚开始考虑过购买VPS服务来实现，但是想到我现阶段的使用目的只是单纯记录我在后续工作、生活中的一些事情，也不追求访问速度，Github Pages服务可以满足我的需求（其中一个主要原因是Github Pages可以免费提供静态站点服务）。在确定好服务端之后，接着就是考虑内容生成工具，在网上查了一圈之后,从所需要准备的环境，以及内容编写工具以及维护程度等方面来考虑，最后还是选择Hexo。 搭建过程 由于自己的电脑上已经有nodejs、git等hexo所需要的工具，所以在搭建的过程中很快速，步骤也很简单（但是自己还是折腾了好长时间，后面再述），首先使用命令npm install -g hexo-cli安装好hexo基础环境，可执行程序。关于hexo教程可以到这里学习。在基础环境齐全之后，操作如下命令： hexo init &quot;project name&quot;，创建一个Hexo项目，后续的操作都在这个项目文件夹里面进行； hexo new [layout] &quot;title&quot;，创建一个文档，后续编写blog内容都可以通过这个命令来创建对应的md文件;默认情况下，创建的文档位于source/_posts/路径下； hexo generate 将该项目下的文档生成静态网页，生成内容位于public目录下； hexo server 启动一个本地服务，默认访问地址为http://localhost:4000/，可以通过该地址的内容进行预览；通过上面几步，一个blog的内容生成，预览基本上就完成了，但是我们还需要将生成的内容上传到github仓库中。通过Github Pages介绍我们知道，要想启用这个服务，我们需要在自己的github仓库中创建一个 “user”.github.io的项目，然后将public中的内容上传到该项目中即可。为方便上传内容到github，需要安装插件npm install hexo-deployer-git，同时在打开根目录中的_config.yml文件，在文档最后部分# Deployment增加如下配置，1234deploy: type: git repo: git@github.com:jeremymj/jeremymj.github.io.git branch: master 其中repo为将要上传的路径，为减少上传代码时需要输入github用户名、密码，我在这里使用了ssh方式上传，使用https方式也是可以的。在完成上述配置后，就可以使用命令hexo deploy将代码上传到github对应仓库中。自定义域名 在通过以上几个步骤的操作，正常情况下在浏览器中输入地址项目地址，比如我的:jeremymj.github.io,就可以打开blog的首页。但是假如我们不想使用这个项目地址访问blog，则我们可以为我们的blog绑定一个自己的域名。关于域名的购买，自己随便选择一个服务商就行。在域名中增加一条CNAME解析，eg：CNAME www.jspace.top jeremymj.github.io,不同的DNS服务商这里显示根式有所区别。正常情况下，一段时间后就可以通过配置的域名访问我们的blog了。支持https访问 现在github pages服务直接支持https服务，默认情况下使用xxx.github.io的方式访问，直接是https方式。针对自定义的域名路径，支持https也不再需要通过中间代理就可以直实现。操作方式也很方便，在我们创建的github.io项目仓库中找到Settings选项，找到GitHub Pages设置模块，在Custom domain中填上我们自定义的域名，选中Enforce HTTPS 选项即可。为了是刚才的配置生效，我们还需要到为我们的域名在家几条A类型记录，主机记录这个字段，在有些服务商的配置文件中是填写@,有些服务商直接不支持@类型的则这个字段不用填写，保持默认即可。对应的值为185.199.108.153、185.199.109.153、185.199.110.153、185.199.111.153中的任意一个，这里我增加了4条A类型记录。配置好后，正常情况下，一段时间后就可以通过我们自定义的域名使用https访问我们的blog。主题更换 选择hexo做为blog的内容生成工具，是因为它有很多主题模板供我们使用。我在尝试了几个主题后，考虑到github提供的服务在国内访问速度的问题，最后还是使用的一个大家用的比较多的next模板，主题的替换很简单，在项目的根目录下使用命令:git clone https://github.com/theme-next/hexo-theme-next themes/next,将主题模板取回来放置在themes文件夹下，如果要启用该模板，修改项目文件夹下_config.yml文件theme字段，值设置为：next。剩下的就是修改next文件下的配置文件，启用该主题的各种样式效果。代码管理 为后续代码管理以及编写文档的保存，需要把项目上传到github管理，这里存在一个发布后的文件和源文件。根据我们在搭建过程中对_config.yml的设置，我们把发布后的文件保存在项目的master分支，则针对源文件就上传到该项目下一个分支来保存。在项目根目录下使用命令git init将该项目转换为git管理项目，添加远程仓库地址git remote add origin git@github.com:jeremymj/jeremymj.github.io.git，创建.gitignore文件，选择哪些文件不需要上传到github来管理。接着我们开始创建分支gh_dev，使用命令git branch gh_dev,使用命令git push origin gh_dev则可以把源文件提交到远程分支来管理。以后的操作都在本地分支gh_dev来完成,在编辑完成后通过hexo deploy发布到远端mater即可遇到的问题 这里列一些在搭建的过程中遇到的问题:cb() never called 在使用npm 方式来安装hexo 可执行程序时，遇到速度很慢的问题，但是在我的环境里面启用了自动代理，照理说应该会走代理的，就使用命令npm config set proxy=http://127.0.0.1:1080配置代理，后面拉取代码的速度果然有明显的提升，但是在拉取代码的过程中，出现错误提示，cb() never called。最后进入项目目录尝试使用npm install 获取刚才没有拉下来的代码，也是出现错误提示，在一篇帖子的提醒下，想起在配置代理的时候，当时查看的那个网页上给出的教程是 12npm config set proxy=http://127.0.0.1:8087npm config set registry=http://registry.npmjs.org 但是我想到只需要proxy,就没有配置registry,在添加好registry后，再次使用npm install，cb() never called！没有再次出现了，对于出现这个问题的原因，猜测是在默认情况下，npm在执行过程中会有默认registry。我在添加代理的过程中只指定了proxy,系统不再使用默认的registry，对于这个猜测，感觉也不合理，没有道理在用户没有指定registry时，不使用默认registry！由于现在没有对应环境来验证，先在这里记录一下。自定义域名失效 在测试的过程中，发现在使用hexo deploy后，有时会存在自定义域名不生效，需要在Settings界面重新设置。最后在源文件目录(本地gh_dev分支)中增加一个CNAME配置文件，在配置文件中填写www.jspace.top即可以解决这个问题总结 以上就是使用hexo搭建blog的过程，关于使用next主题配置的操作，也不再详细说，里面的配置项很多，针对配置项不能够满足我们对效果期望的地方，可以直接修改对应的css文件。关于样式的美化，需要花费的时间比较多，后续再慢慢的优化，至少目前是有一个地方，可以记录自己的学习笔记。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.jspace.top/tags/hexo/"}]}]}